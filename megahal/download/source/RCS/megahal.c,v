head	1.25;
access;
symbols;
locks
	hutch:1.25; strict;
comment	@ * @;


1.25
date	99.10.21.03.42.48;	author hutch;	state Exp;
branches;
next	1.24;

1.24
date	98.09.03.03.07.09;	author hutch;	state Exp;
branches;
next	1.23;

1.23
date	98.05.19.03.02.02;	author hutch;	state Exp;
branches;
next	1.22;

1.22
date	98.04.24.03.47.03;	author hutch;	state Exp;
branches;
next	1.21;

1.21
date	98.04.24.03.39.51;	author hutch;	state Exp;
branches;
next	1.20;

1.20
date	98.04.22.07.12.37;	author hutch;	state Exp;
branches;
next	1.19;

1.19
date	98.04.21.10.10.56;	author hutch;	state Exp;
branches;
next	1.18;

1.18
date	98.04.06.08.02.01;	author hutch;	state Exp;
branches;
next	1.17;

1.17
date	98.04.02.01.34.20;	author hutch;	state Exp;
branches;
next	1.16;

1.16
date	98.04.01.05.42.57;	author hutch;	state Exp;
branches;
next	1.15;

1.15
date	98.03.27.03.43.15;	author hutch;	state Exp;
branches;
next	1.14;

1.14
date	98.02.20.06.40.13;	author hutch;	state Exp;
branches;
next	1.13;

1.13
date	98.02.20.06.26.19;	author hutch;	state Exp;
branches;
next	1.12;

1.12
date	98.02.04.02.55.11;	author hutch;	state Exp;
branches;
next	1.11;

1.11
date	98.01.22.03.16.30;	author hutch;	state Exp;
branches;
next	1.10;

1.10
date	98.01.19.06.44.36;	author hutch;	state Exp;
branches;
next	1.9;

1.9
date	98.01.19.06.37.32;	author hutch;	state Exp;
branches;
next	1.8;

1.8
date	97.12.24.03.17.01;	author hutch;	state Exp;
branches;
next	1.7;

1.7
date	97.12.22.13.18.09;	author hutch;	state Exp;
branches;
next	1.6;

1.6
date	97.12.22.04.27.04;	author hutch;	state Exp;
branches;
next	1.5;

1.5
date	97.12.15.04.35.59;	author hutch;	state Exp;
branches;
next	1.4;

1.4
date	97.12.11.05.45.29;	author hutch;	state Exp;
branches;
next	1.3;

1.3
date	97.12.10.09.08.09;	author hutch;	state Exp;
branches;
next	1.2;

1.2
date	97.12.08.06.22.32;	author hutch;	state Exp;
branches;
next	1.1;

1.1
date	97.12.05.07.11.44;	author hutch;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Fixed problem on some operating systems caused by stderr and stdout not
being of type FILE *.
@
text
@/*===========================================================================*/
/*
 *  Copyright (C) 1998/1999 Jason Hutchens
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the license or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the Gnu Public License for more
 *  details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  675 Mass Ave, Cambridge, MA 02139, USA.
 */
/*===========================================================================*/
/*
 *		$Id: megahal.c,v 1.24 1998/09/03 03:07:09 hutch Exp hutch $
 *
 *		File:			megahal.c
 *
 *		Program:		MegaHAL v8r6
 *
 *		Purpose:		To simulate a natural language conversation with a psychotic
 *						computer.  This is achieved by learning from the user's
 *						input using a third-order Markov model on the word level.
 *						Words are considered to be sequences of characters separated
 *						by whitespace and punctuation.  Replies are generated
 *						randomly based on a keyword, and they are scored using
 *						measures of surprise.
 *
 *		Author:		Mr. Jason L. Hutchens
 *
 *		WWW:			http://ciips.ee.uwa.edu.au/~hutch/hal/
 *
 *		E-Mail:		hutch@@ciips.ee.uwa.edu.au
 *
 *		Contact:		The Centre for Intelligent Information Processing Systems
 *						Department of Electrical and Electronic Engineering
 *						The University of Western Australia
 *						AUSTRALIA 6907
 *
 *		Phone:		+61-8-9380-3856
 *
 *		Facsimile:	+61-8-9380-1168
 *
 *		Notes:		- This file is best viewed with tabstops set to three spaces.
 *						- To the Debian guys, yes, it's only one file, so shoot me!
 *						  I had to get it to work on DOS with crappy compilers and
 *						  I didn't want to spend more time than was neccessary.
 *						  Hence it's rather monolithic.  Also, an email would be
 *						  appreciated whenever bugs were fixed/discovered.  I've
 *						  terminated all of the memory leakage bugs AFAICT.  But
 *						  it does allocate a helluva lot of memory, I'll admit!
 *
 *		Compilation Notes
 *		=================
 *
 *		When compiling, be sure to link with the maths library so that the
 *		log() function can be found.
 *
 *		On the Macintosh, add the library SpeechLib to your project.  It is
 *		very important that you set the attributes to Import Weak.  You can
 *		do this by selecting the lib and then use Project Inspector from the
 *		Window menu.
 *
 *		CREDITS
 *		=======
 *
 *		Amiga (AmigaOS)
 *		---------------
 *		Dag Agren (dagren@@ra.abo.fi)
 *
 *		DEC (OSF)
 *		---------
 *		Jason Hutchens (hutch@@ciips.ee.uwa.edu.au)
 *
 *		Macintosh
 *		---------
 *		Paul Baxter (pbaxter@@assistivetech.com)
 *		Doug Turner (dturner@@best.com)
 *
 *		PC (Linux - Debian package)
 *		---------------------------
 *		Joey Hess (joeyh@@master.debian.org)
 *
 *		PC (OS/2)
 *		---------
 *		Bjorn Karlowsky (?)
 *
 *		PC (Windows 3.11)
 *		-----------------
 *		Jim Crawford (pfister_@@hotmail.com)
 *
 *		PC (Windows '95)
 *		----------------
 *		Jason Hutchens (hutch@@ciips.ee.uwa.edu.au)
 *
 *		PPC (Linux)
 *		-----------
 *		Lucas Vergnettes (Lucasv@@sdf.lonestar.org)
 *
 *		SGI (Irix)
 *		----------
 *		Jason Hutchens (hutch@@ciips.ee.uwa.edu.au)
 *
 *		Sun (SunOS)
 *		-----------
 *		Jason Hutchens (hutch@@ciips.ee.uwa.edu.au)
 */
/*===========================================================================*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#if !defined(AMIGA) && !defined(__mac_os)
#include <malloc.h>
#endif
#include <string.h>
#include <signal.h>
#include <math.h>
#include <time.h>
#include <ctype.h>
#if defined(__mac_os)
#include <types.h>
#include <Speech.h>
#else
#include <sys/types.h>
#endif
#include "megahal.h"
#if defined(DEBUG)
#include "debug.h"
#endif

/*===========================================================================*/

void add_aux(MODEL *, DICTIONARY *, STRING);
void add_key(MODEL *, DICTIONARY *, STRING);
void add_node(TREE *, TREE *, int);
void add_swap(SWAP *, char *, char *);
TREE *add_symbol(TREE *, BYTE2);
BYTE2 add_word(DICTIONARY *, STRING);
int babble(MODEL *, DICTIONARY *, DICTIONARY *);
bool boundary(char *, int);
void capitalize(char *);
void changevoice(DICTIONARY *, int);
void change_personality(DICTIONARY *, int, MODEL **);
void change_think(DICTIONARY *, int);
void delay(char *);
void die(int);
bool dissimilar(DICTIONARY *, DICTIONARY *);
void error(char *, char *, ...);
float evaluate_reply(MODEL *, DICTIONARY *, DICTIONARY *);
COMMAND_WORDS execute_command(DICTIONARY *, int *);
void exithal(void);
TREE *find_symbol(TREE *, int);
TREE *find_symbol_add(TREE *, int);
BYTE2 find_word(DICTIONARY *, STRING);
char *format_output(char *);
void free_dictionary(DICTIONARY *);
void free_model(MODEL *);
void free_tree(TREE *);
void free_word(STRING);
void free_words(DICTIONARY *);
char *generate_reply(MODEL *, DICTIONARY *);
void help(void);
void ignore(int);
void initialize_context(MODEL *);
void initialize_dictionary(DICTIONARY *);
bool initialize_error(char *);
DICTIONARY *initialize_list(char *);
#ifdef __mac_os
bool initialize_speech(void);
#endif
bool initialize_status(char *);
SWAP *initialize_swap(char *);
void learn(MODEL *, DICTIONARY *);
void listvoices(void);
void load_dictionary(FILE *, DICTIONARY *);
bool load_model(char *, MODEL *);
void load_personality(MODEL **);
void load_tree(FILE *, TREE *);
void load_word(FILE *, DICTIONARY *);
void make_greeting(DICTIONARY *);
DICTIONARY *make_keywords(MODEL *, DICTIONARY *);
char *make_output(DICTIONARY *);
void make_words(char *, DICTIONARY *);
DICTIONARY *new_dictionary(void);
MODEL *new_model(int);
TREE *new_node(void);
SWAP *new_swap(void);
bool print_header(FILE *);
bool progress(char *, int, int);
char *read_input(char *);
DICTIONARY *reply(MODEL *, DICTIONARY *);
void save_dictionary(FILE *, DICTIONARY *);
void save_model(char *, MODEL *);
void save_tree(FILE *, TREE *);
void save_word(FILE *, STRING);
int search_dictionary(DICTIONARY *, STRING, bool *);
int search_node(TREE *, int, bool *);
int seed(MODEL *, DICTIONARY *);
void show_dictionary(DICTIONARY *);
void speak(char *);
bool status(char *, ...);
#ifdef __mac_os
char *strdup(const char *);
#endif
void train(MODEL *, char *);
void typein(char);
void update_context(MODEL *, int);
void update_model(MODEL *, int);
void upper(char *);
bool warn(char *, char *, ...);
int wordcmp(STRING, STRING);
bool word_exists(DICTIONARY *, STRING);
void write_input(char *);
void write_output(char *);
int rnd(int);
#if defined(DOS) || defined(__mac_os)
void usleep(int);
#endif

/*===========================================================================*/

int width=75;
int order=5;
int timeout=2;
bool typing_delay=FALSE;
bool speech=FALSE;
bool prog=TRUE;
DICTIONARY *ban=NULL;
DICTIONARY *aux=NULL;
DICTIONARY *fin=NULL;
DICTIONARY *grt=NULL;
SWAP *swp=NULL;
FILE *errorfp=NULL;
FILE *statusfp=NULL;
bool used_key;
char *directory=NULL;
char *last=NULL;

COMMAND command[] = {
	{ { 5, "BRAIN" }, "change to another MegaHAL personality", BRAIN },
	{ { 5, "DELAY" }, "toggles MegaHAL's typing delay (off by default)", DELAY },
	{ { 4, "EXIT" }, "exits the program without saving MegaHAL's brain", EXIT },
	{ { 4, "HELP" }, "displays this message", HELP },
	{ { 4, "PROG" }, "toggle the progress display (on by default)", PROGRESS },
	{ { 4, "QUIT" }, "quits the program and saves MegaHAL's brain", QUIT },
	{ { 4, "SAVE" }, "saves the current MegaHAL brain", SAVE },
	{ { 6, "SPEECH" }, "toggles MegaHAL's speech (off by default)", SPEECH },
	{ { 5, "THINK" }, "changes MegaHAL's thinking time (2 by default)", THINK },
	{ { 5, "VOICE" }, "switches to voice specified", VOICE },
	{ { 6, "VOICES" }, "list available voices for speech", VOICELIST }
};

#ifdef AMIGA
struct Locale *_AmigaLocale;
#endif

#ifdef __mac_os
Boolean gSpeechExists = false;
SpeechChannel gSpeechChannel = nil;
#endif

/*===========================================================================*/

/*
 *		Function:	Main
 *
 *		Purpose:		Initialise everything, and then do an infinite loop.  In
 *						the loop, we read the user's input and reply to it, and
 *						do some housekeeping task such as responding to special
 *						commands.
 */
int main(int argc, char **argv)
{
	char *input=NULL;
	char *output=NULL;
	DICTIONARY *words=NULL;
	DICTIONARY *greets=NULL;
	MODEL *model=NULL;
	int position=0;

	/*
	 *		Do some initialisation 
	 */
	initialize_error("megahal.log");
	initialize_status("megahal.txt");
	ignore(0);
#ifdef AMIGA
	_AmigaLocale=OpenLocale(NULL);
#endif
#ifdef __mac_os
	gSpeechExists = initialize_speech();
#endif

fprintf(stdout,
"+------------------------------------------------------------------------+\n"
"|                                                                        |\n"
"|  #    #  ######   ####     ##    #    #    ##    #                     |\n"
"|  ##  ##  #       #    #   #  #   #    #   #  #   #               ###   |\n"
"|  # ## #  #####   #       #    #  ######  #    #  #              #   #  |\n"
"|  #    #  #       #  ###  ######  #    #  ######  #       #   #   ###   |\n"
"|  #    #  #       #    #  #    #  #    #  #    #  #        # #   #   #  |\n"
"|  #    #  ######   ####   #    #  #    #  #    #  ######    #     ###r6 |\n"
"|                                                                        |\n"
"|                    Copyright(C) 1998 Jason Hutchens                    |\n"
"+------------------------------------------------------------------------+\n"
);

	/*
	 *		Create a dictionary which will be used to hold the segmented
	 *		version of the user's input.
	 */
	words=new_dictionary();
	greets=new_dictionary();

	/*
	 *		Load the default MegaHAL personality.
	 */
	change_personality(NULL, 0, &model);
	make_greeting(greets);
	output=generate_reply(model, greets);
	write_output(output);
	/*
	 *		Read input, formulate a reply and display it as output
	 */
	while(TRUE) {
		input=read_input("> ");
		write_input(input);
		make_words(input,words);

		/*
		 *		If the input was a command, then execute it
		 */
		switch(execute_command(words, &position)) {
			case EXIT:
				exithal();
			case QUIT:
				save_model("megahal.brn", model);
				exithal();
			case SAVE:
				save_model("megahal.brn", model);
				continue;
			case DELAY:
				typing_delay=!typing_delay;
				printf("MegaHAL typing is now %s.\n", typing_delay?"on":"off");
				continue;
			case SPEECH:
				speech=!speech;
				printf("MegaHAL speech is now %s.\n", speech?"on":"off");
				continue;
			case HELP:
				help();
				continue;
			case VOICELIST:
				listvoices();
				continue;
			case VOICE:
				changevoice(words, position);
				continue;
			case BRAIN:
				change_personality(words, position, &model);
				make_greeting(greets);
				output=generate_reply(model, greets);
				write_output(output);
				continue;
			case PROGRESS:
				prog=!prog;
				printf("MegaHAL progress display is now %s.\n", prog?"on":"off");
				continue;
			case THINK:
				change_think(words, position);
				continue;
			default:
				break;	
		}

		upper(input);
		make_words(input,words);
		learn(model, words);
		output=generate_reply(model, words);
		write_output(output);
	}

#ifdef AMIGA
	CloseLocale(_AmigaLocale);
#endif

	return(0);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Execute_Command
 *
 *		Purpose:		Detect whether the user has typed a command, and
 *						execute the corresponding function.
 */
COMMAND_WORDS execute_command(DICTIONARY *words, int *position)
{
	register int i;
	register int j;

	/*
	 *		If there is only one word, then it can't be a command.
	 */
	*position=words->size+1;
	if(words->size<=1) return(UNKNOWN);

	/*
	 *		Search through the word array.  If a command prefix is found,
	 *		then try to match the following word with a command word.  If
	 *		a match is found, then return a command identifier.  If the
	 *		Following word is a number, then change the judge.  Otherwise,
	 *		continue the search.
	 */
	for(i=0; i<words->size-1; ++i)
		/*
		 *		The command prefix was found.
		 */
		if(words->entry[i].word[words->entry[i].length-1]=='#') {
			/*
			 *		Look for a command word.
			 */
			for(j=0; j<COMMAND_SIZE; ++j)
				if(wordcmp(command[j].word, words->entry[i+1])==0) {
					*position=i+1;
					return(command[j].command);
				}
		}

	return(UNKNOWN);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	ExitHAL
 *
 *		Purpose:		Terminate the program.
 */
void exithal(void)
{
#ifdef __mac_os
	/*
	 *		Must be called because it does use some system memory
	 */
	if (gSpeechChannel) {
		StopSpeech(gSpeechChannel);
		DisposeSpeechChannel(gSpeechChannel);
		gSpeechChannel = nil;
	}
#endif

	exit(0);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Read_Input
 *
 *		Purpose:		Read an input string from the user.
 */
char *read_input(char *prompt)
{
	static char *input=NULL;
	bool finish;
	int length;
	int c;

	/*
	 *		Perform some initializations.  The finish boolean variable is used
	 *		to detect a double line-feed, while length contains the number of
	 *		characters in the input string.
	 */
	finish=FALSE;
	length=0;
	if(input==NULL) {
		input=(char *)malloc(sizeof(char));
		if(input==NULL) {
			error("read_input", "Unable to allocate the input string");
			return(input);
		}
	}

	/* 
	 *		Display the prompt to the user.
	 */
	fprintf(stdout, prompt);
	fflush(stdout);

	/*
	 *		Loop forever, reading characters and putting them into the input
	 *		string.
	 */
	while(TRUE) {

		/*
		 *		Read a single character from stdin.
		 */
		c=getc(stdin);

		/*
		 *		If the character is a line-feed, then set the finish variable
		 *		to TRUE.  If it already is TRUE, then this is a double line-feed,
		 *		in which case we should exit.  After a line-feed, display the
		 *		prompt again, and set the character to the space character, as
		 *		we don't permit linefeeds to appear in the input.
		 */
		if((char)(c)=='\n') {
			if(finish==TRUE) break;
			fprintf(stdout, prompt);
			fflush(stdout);
			finish=TRUE;
			c=32;
		} else {
			finish=FALSE;
		}

		/*
		 *		Re-allocate the input string so that it can hold one more
		 *		character.
		 */
		++length;
		input=(char *)realloc((char *)input,sizeof(char)*(length+1));
		if(input==NULL) {
			error("read_input", "Unable to re-allocate the input string");
			return(NULL);
		}

		/*
		 *		Add the character just read to the input string.
		 */
		input[length-1]=(char)c;
		input[length]='\0';
	}

	while(isspace(input[length-1])) --length;
	input[length]='\0';

	/*
	 *		We have finished, so return the input string.
	 */
	return(input);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Initialize_Error
 *
 *		Purpose:		Close the current error file pointer, and open a new one.
 */
bool initialize_error(char *filename)
{
	if(errorfp!=NULL) fclose(errorfp);
	if(filename==NULL) return(TRUE);
	errorfp=fopen(filename, "a");
	if(errorfp==NULL) {
		return(FALSE);
	}
	return(print_header(errorfp));
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Error
 *
 *		Purpose:		Print the specified message to the error file.
 */
void error(char *title, char *fmt, ...)
{
	va_list argp;

	if(errorfp!=NULL) {
		fprintf(errorfp, "%s: ", title);
		va_start(argp, fmt);
		vfprintf(errorfp, fmt, argp);
		va_end(argp);
		fprintf(errorfp, ".\n");
		fflush(errorfp);
	} else {
		fprintf(stderr, "%s: ", title);
		va_start(argp, fmt);
		vfprintf(stderr, fmt, argp);
		va_end(argp);
		fprintf(stderr, ".\n");
		fflush(stderr);
	}

	fprintf(stderr, "MegaHAL died for some reason; check the error log.\n");

	exit(1);
}

/*---------------------------------------------------------------------------*/

bool warn(char *title, char *fmt, ...)
{
	va_list argp;

	if(errorfp!=NULL) {
		fprintf(errorfp, "%s: ", title);
		va_start(argp, fmt);
		vfprintf(errorfp, fmt, argp);
		va_end(argp);
		fprintf(errorfp, ".\n");
		fflush(errorfp);
	} else {
		fprintf(stderr, "%s: ", title);
		va_start(argp, fmt);
		vfprintf(stderr, fmt, argp);
		va_end(argp);
		fprintf(stderr, ".\n");
		fflush(stderr);
	}

	fprintf(stderr, "MegaHAL emitted a warning; check the error log.\n");

	return(TRUE);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Initialize_Status
 *
 *		Purpose:		Close the current status file pointer, and open a new one.
 */
bool initialize_status(char *filename)
{
	if(statusfp!=NULL) fclose(statusfp);
	if(filename==NULL) return(FALSE);
	statusfp=fopen(filename, "a");
	if(statusfp==NULL) {
		return(FALSE);
	}
	return(print_header(statusfp));
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Status
 *
 *		Purpose:		Print the specified message to the status file.
 */
bool status(char *fmt, ...)
{
	va_list argp;

	if(statusfp!=NULL) {
		va_start(argp, fmt);
		vfprintf(statusfp, fmt, argp);
		va_end(argp);
		fflush(statusfp);
	} else {
		va_start(argp, fmt);
		vfprintf(stdout, fmt, argp);
		va_end(argp);
		fflush(stdout);
	}

	return(TRUE);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Print_Header
 *
 *		Purpose:		Display a copyright message and timestamp.
 */
bool print_header(FILE *file)
{
	time_t clock;
	char timestamp[1024];
	struct tm *local;

	clock=time(NULL);
	local=localtime(&clock);
	strftime(timestamp, 1024, "Start at: [%Y/%m/%d %H:%M:%S]\n", local);

	fprintf(file, "MegaHALv8\n");
	fprintf(file, "Copyright (C) 1998 Jason Hutchens\n");
	fprintf(file, timestamp);
	fflush(file);

	return(TRUE);
}

/*---------------------------------------------------------------------------*/

/*
 *    Function:   Write_Output
 *
 *    Purpose:    Display the output string.
 */
void write_output(char *output)
{
   char *formatted;
   char *bit;
 
	capitalize(output);
	speak(output);

	width=75;
	formatted=format_output(output);
	delay(formatted);
	width=64;
	formatted=format_output(output);
 
	bit=strtok(formatted, "\n");
	if(bit==NULL) (void)status("MegaHAL: %s\n", formatted);
	while(bit!=NULL) {
		(void)status("MegaHAL: %s\n", bit);
		bit=strtok(NULL, "\n");
	}
}
 
/*---------------------------------------------------------------------------*/

/*
 *		Function:	Capitalize
 *
 *		Purpose:		Convert a string to look nice.
 */
void capitalize(char *string)
{
	register int i;
	bool start=TRUE;

	for(i=0; i<(int)strlen(string); ++i) {
		if(isalpha(string[i])) {
			if(start==TRUE) string[i]=(char)toupper((int)string[i]);
			else string[i]=(char)tolower((int)string[i]);
			start=FALSE;
		}
		if((i>2)&&(strchr("!.?", string[i-1])!=NULL)&&(isspace(string[i])))
			start=TRUE;
	}
}
 
/*---------------------------------------------------------------------------*/

/*
 *		Function:	Upper
 *
 *		Purpose:		Convert a string to its uppercase representation.
 */
void upper(char *string)
{
	register int i;

	for(i=0; i<(int)strlen(string); ++i) string[i]=(char)toupper((int)string[i]);
}
 
/*---------------------------------------------------------------------------*/

/*
 *    Function:   Write_Input
 *
 *    Purpose:    Log the user's input
 */
void write_input(char *input)
{
   char *formatted;
   char *bit;
 
	width=64;
   formatted=format_output(input);

   bit=strtok(formatted, "\n");
	if(bit==NULL) (void)status("User:    %s\n", formatted);
   while(bit!=NULL) {
      (void)status("User:    %s\n", bit);
      bit=strtok(NULL, "\n");
   }
}

/*---------------------------------------------------------------------------*/

/*
 *    Function:   Format_Output
 *
 *    Purpose:    Format a string to display nicely on a terminal of a given
 *                width.
 */
char *format_output(char *output)
{
   static char *formatted=NULL;
   register int i,j,c;
   int l;

   if(formatted==NULL) {
      formatted=(char *)malloc(sizeof(char));
      if(formatted==NULL) {
         error("format_output", "Unable to allocate formatted");
         return("ERROR");
      }
   }   

   formatted=(char *)realloc((char *)formatted, sizeof(char)*(strlen(output)+2));
   if(formatted==NULL) {
      error("format_output", "Unable to re-allocate formatted");
      return("ERROR");
   }

   l=0;
	j=0;
   for(i=0; i<(int)strlen(output); ++i) {
      if((l==0)&&(isspace(output[i]))) continue;
      formatted[j]=output[i];
      ++j;
      ++l;
      if(l>=width)
         for(c=j-1; c>0; --c)
            if(formatted[c]==' ') {
               formatted[c]='\n';
               l=j-c-1;
               break;
            }
   }
	if((j>0)&&(formatted[j-1]!='\n')) {
		formatted[j]='\n';
		++j;
	}
   formatted[j]='\0';

   return(formatted);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Add_Word
 *
 *		Purpose:		Add a word to a dictionary, and return the identifier
 *						assigned to the word.  If the word already exists in
 *						the dictionary, then return its current identifier
 *						without adding it again.
 */
BYTE2 add_word(DICTIONARY *dictionary, STRING word)
{
	register int i;
	int position;
	bool found;

	/* 
	 *		If the word's already in the dictionary, there is no need to add it
	 */
	position=search_dictionary(dictionary, word, &found);
	if(found==TRUE) goto succeed;

	/* 
	 *		Increase the number of words in the dictionary
	 */
	dictionary->size+=1;

	/*
	 *		Allocate one more entry for the word index
	 */
	if(dictionary->index==NULL) {
		dictionary->index=(BYTE2 *)malloc(sizeof(BYTE2)*
		(dictionary->size));
	} else {
		dictionary->index=(BYTE2 *)realloc((BYTE2 *)
		(dictionary->index),sizeof(BYTE2)*(dictionary->size));
	}
	if(dictionary->index==NULL) {
		error("add_word", "Unable to reallocate the index.");
		goto fail;
	}

	/*
	 *		Allocate one more entry for the word array
	 */
	if(dictionary->entry==NULL) {
		dictionary->entry=(STRING *)malloc(sizeof(STRING)*(dictionary->size));
	} else {
		dictionary->entry=(STRING *)realloc((STRING *)(dictionary->entry),
		sizeof(STRING)*(dictionary->size));
	}
	if(dictionary->entry==NULL) {
		error("add_word", "Unable to reallocate the dictionary to %d elements.", dictionary->size);
		goto fail;
	}

	/*
	 *		Copy the new word into the word array
	 */
	dictionary->entry[dictionary->size-1].length=word.length;
	dictionary->entry[dictionary->size-1].word=(char *)malloc(sizeof(char)*
	(word.length));
	if(dictionary->entry[dictionary->size-1].word==NULL) {
		error("add_word", "Unable to allocate the word.");
		goto fail;
	}
	for(i=0; i<word.length; ++i)
		dictionary->entry[dictionary->size-1].word[i]=word.word[i];

	/*
	 *		Shuffle the word index to keep it sorted alphabetically
	 */
	for(i=(dictionary->size-1); i>position; --i)
		dictionary->index[i]=dictionary->index[i-1];

	/*
	 *		Copy the new symbol identifier into the word index
	 */
	dictionary->index[position]=dictionary->size-1;

succeed:
	return(dictionary->index[position]);

fail:
	return(0);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Search_Dictionary
 *
 *		Purpose:		Search the dictionary for the specified word, returning its
 *						position in the index if found, or the position where it
 *						should be inserted otherwise.
 */
int search_dictionary(DICTIONARY *dictionary, STRING word, bool *find)
{
	int position;
	int min;
	int max;
	int middle;
	int compar;

	/*
	 *		If the dictionary is empty, then obviously the word won't be found
	 */
	if(dictionary->size==0) {
		position=0;
		goto notfound;
	}

	/*
	 *		Initialize the lower and upper bounds of the search
	 */
	min=0;
	max=dictionary->size-1;
	/*
	 *		Search repeatedly, halving the search space each time, until either
	 *		the entry is found, or the search space becomes empty
	 */
	while(TRUE) {
		/*
		 *		See whether the middle element of the search space is greater
		 *		than, equal to, or less than the element being searched for.
		 */
		middle=(min+max)/2;
		compar=wordcmp(word, dictionary->entry[dictionary->index[middle]]);
		/*
		 *		If it is equal then we have found the element.  Otherwise we
		 *		can halve the search space accordingly.
		 */
		if(compar==0) {
			position=middle;
			goto found;
		} else if(compar>0) {
			if(max==middle) {
				position=middle+1;
				goto notfound;
			}
			min=middle+1;
		} else {
			if(min==middle) {
				position=middle;
				goto notfound;
			}
			max=middle-1;
		}
	}

found:
	*find=TRUE;
	return(position);

notfound:
	*find=FALSE;
	return(position);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Find_Word
 *
 *		Purpose:		Return the symbol corresponding to the word specified.
 *						We assume that the word with index zero is equal to a
 *						NULL word, indicating an error condition.
 */
BYTE2 find_word(DICTIONARY *dictionary, STRING word)
{
	int position;
	bool found;

	position=search_dictionary(dictionary, word, &found);

	if(found==TRUE) return(dictionary->index[position]);
	else return(0);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Wordcmp
 *
 *		Purpose:		Compare two words, and return an integer indicating whether
 *						the first word is less than, equal to or greater than the
 *						second word.
 */
int wordcmp(STRING word1, STRING word2)
{
	register int i;
	int bound;

	bound=MIN(word1.length,word2.length);

	for(i=0; i<bound; ++i)
		if(toupper(word1.word[i])!=toupper(word2.word[i]))
			return((int)(toupper(word1.word[i])-toupper(word2.word[i])));

	if(word1.length<word2.length) return(-1);
	if(word1.length>word2.length) return(1);

	return(0);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Free_Dictionary
 *
 *		Purpose:		Release the memory consumed by the dictionary.
 */
void free_dictionary(DICTIONARY *dictionary)
{
	if(dictionary==NULL) return;
	if(dictionary->entry!=NULL) {
		free(dictionary->entry);
		dictionary->entry=NULL;
	}
	if(dictionary->index!=NULL) {
		free(dictionary->index);
		dictionary->index=NULL;
	}
	dictionary->size=0;
}

/*---------------------------------------------------------------------------*/

void free_model(MODEL *model)
{
	if(model==NULL) return;
	if(model->forward!=NULL) {
		free_tree(model->forward);
	}
	if(model->backward!=NULL) {
		free_tree(model->backward);
	}
	if(model->context!=NULL) {
		free(model->context);
	}
	if(model->dictionary!=NULL) {
		free_dictionary(model->dictionary);
		free(model->dictionary);
	}
	free(model);
}

/*---------------------------------------------------------------------------*/

void free_tree(TREE *tree)
{
	static int level=0;
	register int i;

	if(tree==NULL) return;

	if(tree->tree!=NULL) {
		if(level==0) progress("Freeing tree", 0, 1);
		for(i=0; i<tree->branch; ++i) {
			++level;
			free_tree(tree->tree[i]);
			--level;
			if(level==0) progress(NULL, i, tree->branch);
		}
		if(level==0) progress(NULL, 1, 1);
		free(tree->tree);
	}
	free(tree);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Initialize_Dictionary
 *
 *		Purpose:		Add dummy words to the dictionary.
 */
void initialize_dictionary(DICTIONARY *dictionary)
{
	STRING word={ 7, "<ERROR>" };
	STRING end={ 5, "<FIN>" };

	(void)add_word(dictionary, word);
	(void)add_word(dictionary, end);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	New_Dictionary
 *
 *		Purpose:		Allocate room for a new dictionary.
 */
DICTIONARY *new_dictionary(void)
{
	DICTIONARY *dictionary=NULL;

	dictionary=(DICTIONARY *)malloc(sizeof(DICTIONARY));
	if(dictionary==NULL) {
		error("new_dictionary", "Unable to allocate dictionary.");
		return(NULL);
	}

	dictionary->size=0;
	dictionary->index=NULL;
	dictionary->entry=NULL;

	return(dictionary);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Save_Dictionary
 *
 *		Purpose:		Save a dictionary to the specified file.
 */
void save_dictionary(FILE *file, DICTIONARY *dictionary)
{
	register int i;

	fwrite(&(dictionary->size), sizeof(BYTE4), 1, file);
	progress("Saving dictionary", 0, 1);
	for(i=0; i<dictionary->size; ++i) {
		save_word(file, dictionary->entry[i]);
		progress(NULL, i, dictionary->size);
	}
	progress(NULL, 1, 1);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Load_Dictionary
 *
 *		Purpose:		Load a dictionary from the specified file.
 */
void load_dictionary(FILE *file, DICTIONARY *dictionary)
{
	register int i;
	int size;

	fread(&size, sizeof(BYTE4), 1, file);
	progress("Loading dictionary", 0, 1);
	for(i=0; i<size; ++i) {
		load_word(file, dictionary);
		progress(NULL, i, size);
	}
	progress(NULL, 1, 1);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Save_Word
 *
 *		Purpose:		Save a dictionary word to a file.
 */
void save_word(FILE *file, STRING word)
{
	register int i;

	fwrite(&(word.length), sizeof(BYTE1), 1, file);
	for(i=0; i<word.length; ++i)
		fwrite(&(word.word[i]), sizeof(char), 1, file);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Load_Word
 *
 *		Purpose:		Load a dictionary word from a file.
 */
void load_word(FILE *file, DICTIONARY *dictionary)
{
	register int i;
	STRING word;

	fread(&(word.length), sizeof(BYTE1), 1, file);
	word.word=(char *)malloc(sizeof(char)*word.length);
	if(word.word==NULL) {
		error("load_word", "Unable to allocate word");
		return;
	}
	for(i=0; i<word.length; ++i)
		fread(&(word.word[i]), sizeof(char), 1, file);
	add_word(dictionary, word);
	free(word.word);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	New_Node
 *
 *		Purpose:		Allocate a new node for the n-gram tree, and initialise
 *						its contents to sensible values.
 */
TREE *new_node(void)
{
	TREE *node=NULL;

	/*
	 *		Allocate memory for the new node
	 */
	node=(TREE *)malloc(sizeof(TREE));
	if(node==NULL) {
		error("new_node", "Unable to allocate the node.");
		goto fail;
	}

	/*
	 *		Initialise the contents of the node
	 */
	node->symbol=0;
	node->usage=0;
	node->count=0;
	node->branch=0;
	node->tree=NULL;

	return(node);

fail:
	if(node!=NULL) free(node);
	return(NULL);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	New_Model
 *
 *		Purpose:		Create and initialise a new ngram model.
 */
MODEL *new_model(int order)
{
	MODEL *model=NULL;

	model=(MODEL *)malloc(sizeof(MODEL));
	if(model==NULL) {
		error("new_model", "Unable to allocate model.");
		goto fail;
	}

	model->order=order;
	model->forward=new_node();
	model->backward=new_node();
	model->context=(TREE **)malloc(sizeof(TREE *)*(order+2));
	if(model->context==NULL) {
		error("new_model", "Unable to allocate context array.");
		goto fail;
	}
	initialize_context(model);
	model->dictionary=new_dictionary();
	initialize_dictionary(model->dictionary);

	return(model);

fail:
	return(NULL);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Update_Model
 *
 *		Purpose:		Update the model with the specified symbol.
 */
void update_model(MODEL *model, int symbol)
{
	register int i;

	/*
	 *		Update all of the models in the current context with the specified
	 *		symbol.
	 */
	for(i=(model->order+1); i>0; --i)
		if(model->context[i-1]!=NULL)
			model->context[i]=add_symbol(model->context[i-1], (BYTE2)symbol);

	return;
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Update_Context
 *
 *		Purpose:		Update the context of the model without adding the symbol.
 */
void update_context(MODEL *model, int symbol)
{
	register int i;

	for(i=(model->order+1); i>0; --i)
		if(model->context[i-1]!=NULL)
			model->context[i]=find_symbol(model->context[i-1], symbol);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Add_Symbol
 *
 *		Purpose:		Update the statistics of the specified tree with the
 *						specified symbol, which may mean growing the tree if the
 *						symbol hasn't been seen in this context before.
 */
TREE *add_symbol(TREE *tree, BYTE2 symbol)
{
	TREE *node=NULL;

	/*
	 *		Search for the symbol in the subtree of the tree node.
	 */
	node=find_symbol_add(tree, symbol);

	/*
	 *		Increment the symbol counts
	 */
	if((node->count<65535)) {
		node->count+=1;
		tree->usage+=1;
	}

	return(node);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Find_Symbol
 *
 *		Purpose:		Return a pointer to the child node, if one exists, which
 *						contains the specified symbol.
 */
TREE *find_symbol(TREE *node, int symbol)
{
	register int i;
	TREE *found=NULL;
	bool found_symbol=FALSE;

	/* 
	 *		Perform a binary search for the symbol.
	 */
	i=search_node(node, symbol, &found_symbol);
	if(found_symbol==TRUE) found=node->tree[i];

	return(found);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Find_Symbol_Add
 *
 *		Purpose:		This function is conceptually similar to find_symbol,
 *						apart from the fact that if the symbol is not found,
 *						a new node is automatically allocated and added to the
 *						tree.
 */
TREE *find_symbol_add(TREE *node, int symbol)
{
	register int i;
	TREE *found=NULL;
	bool found_symbol=FALSE;

	/* 
	 *		Perform a binary search for the symbol.  If the symbol isn't found,
	 *		attach a new sub-node to the tree node so that it remains sorted.
	 */
	i=search_node(node, symbol, &found_symbol);
	if(found_symbol==TRUE) {
		found=node->tree[i];
	} else {
		found=new_node();
		found->symbol=symbol;
		add_node(node, found, i);
	}

	return(found);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Add_Node
 *
 *		Purpose:		Attach a new child node to the sub-tree of the tree
 *						specified.
 */
void add_node(TREE *tree, TREE *node, int position)
{
	register int i;

	/*
	 *		Allocate room for one more child node, which may mean allocating
	 *		the sub-tree from scratch.
	 */
	if(tree->tree==NULL) {
		tree->tree=(TREE **)malloc(sizeof(TREE *)*(tree->branch+1));
	} else {
		tree->tree=(TREE **)realloc((TREE **)(tree->tree),sizeof(TREE *)*
		(tree->branch+1));
	}
	if(tree->tree==NULL) {
		error("add_node", "Unable to reallocate subtree.");
		return;
	}

	/*
	 *		Shuffle the nodes down so that we can insert the new node at the
	 *		subtree index given by position.
	 */
	for(i=tree->branch; i>position; --i)
		tree->tree[i]=tree->tree[i-1];

	/*
	 *		Add the new node to the sub-tree.
	 */
	tree->tree[position]=node;
	tree->branch+=1;
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Search_Node
 *
 *		Purpose:		Perform a binary search for the specified symbol on the
 *						subtree of the given node.  Return the position of the
 *						child node in the subtree if the symbol was found, or the
 *						position where it should be inserted to keep the subtree
 *						sorted if it wasn't.
 */
int search_node(TREE *node, int symbol, bool *found_symbol)
{
	register int position;
	int min;
	int max;
	int middle;
	int compar;

	/*
	 *		Handle the special case where the subtree is empty.
	 */ 
	if(node->branch==0) {
		position=0;
		goto notfound;
	}

	/*
	 *		Perform a binary search on the subtree.
	 */
	min=0;
	max=node->branch-1;
	while(TRUE) {
		middle=(min+max)/2;
		compar=symbol-node->tree[middle]->symbol;
		if(compar==0) {
			position=middle;
			goto found;
		} else if(compar>0) {
			if(max==middle) {
				position=middle+1;
				goto notfound;
			}
			min=middle+1;
		} else {
			if(min==middle) {
				position=middle;
				goto notfound;
			}
			max=middle-1;
		}
	}

found:
	*found_symbol=TRUE;
	return(position);

notfound:
	*found_symbol=FALSE;
	return(position);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Initialize_Context
 *
 *		Purpose:		Set the context of the model to a default value.
 */
void initialize_context(MODEL *model)
{
	register int i;

	for(i=0; i<=model->order; ++i) model->context[i]=NULL;
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Learn
 *
 *		Purpose:		Learn from the user's input.
 */
void learn(MODEL *model, DICTIONARY *words)
{
	register int i;
	BYTE2 symbol;

	/*
	 *		We only learn from inputs which are long enough
	 */
	if(words->size<=(model->order)) return;

	/*
	 *		Train the model in the forwards direction.  Start by initializing
	 *		the context of the model.
	 */
	initialize_context(model);
	model->context[0]=model->forward;
	for(i=0; i<words->size; ++i) {
		/*
		 *		Add the symbol to the model's dictionary if necessary, and then
		 *		update the forward model accordingly.
		 */
		symbol=add_word(model->dictionary, words->entry[i]);
		update_model(model, symbol);
	}
	/*
	 *		Add the sentence-terminating symbol.
	 */
	update_model(model, 1);

	/*
	 *		Train the model in the backwards direction.  Start by initializing
	 *		the context of the model.
	 */
	initialize_context(model);
	model->context[0]=model->backward;
	for(i=words->size-1; i>=0; --i) {
		/*
		 *		Find the symbol in the model's dictionary, and then update
		 *		the backward model accordingly.
		 */
		symbol=find_word(model->dictionary, words->entry[i]);
		update_model(model, symbol);
	}
	/*
	 *		Add the sentence-terminating symbol.
	 */
	update_model(model, 1);

	return;
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Train
 *
 *		Purpose:	 	Infer a MegaHAL brain from the contents of a text file.
 */
void train(MODEL *model, char *filename)
{
	FILE *file;
	char buffer[1024];
	DICTIONARY *words=NULL;
	int length;

	if(filename==NULL) return;

	file=fopen(filename, "r");
	if(file==NULL) {
		printf("Unable to find the personality %s\n", filename);
		return;
	}

	fseek(file, 0, 2);
   length=ftell(file);
   rewind(file);

	words=new_dictionary();

	progress("Training from file", 0, 1);
	while(!feof(file)) {

		if(fgets(buffer, 1024, file)==NULL) break;
		if(buffer[0]=='#') continue;

		buffer[strlen(buffer)-1]='\0';

		upper(buffer);
		make_words(buffer, words);
		learn(model, words);

		progress(NULL, ftell(file), length);

	}
	progress(NULL, 1, 1);

	free_dictionary(words);
	fclose(file);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Show_Dictionary
 *
 *		Purpose:		Display the dictionary for training purposes.
 */
void show_dictionary(DICTIONARY *dictionary)
{
	register int i;
	register int j;
	FILE *file;

	file=fopen("megahal.dic", "w");
	if(file==NULL) {
		warn("show_dictionary", "Unable to open file");
		return;
	}

	for(i=0; i<dictionary->size; ++i) {
		for(j=0; j<dictionary->entry[i].length; ++j)
			fprintf(file, "%c", dictionary->entry[i].word[j]);
		fprintf(file, "\n");
	}

	fclose(file);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Save_Model
 *
 *		Purpose:		Save the current state to a MegaHAL brain file.
 */
void save_model(char *modelname, MODEL *model)
{
	FILE *file;
	static char *filename=NULL;
	
	if(filename==NULL) filename=(char *)malloc(sizeof(char)*1);

	/*
	 *    Allocate memory for the filename
	 */
	filename=(char *)realloc(filename,
		sizeof(char)*(strlen(directory)+strlen(SEP)+12));
	if(filename==NULL) error("save_model","Unable to allocate filename");

	show_dictionary(model->dictionary);
	if(filename==NULL) return;

	sprintf(filename, "%s%smegahal.brn", directory, SEP);
	file=fopen(filename, "wb");
	if(file==NULL) {
		warn("save_model", "Unable to open file `%s'", filename);
		return;
	}

	fwrite(COOKIE, sizeof(char), strlen(COOKIE), file);
	fwrite(&(model->order), sizeof(BYTE1), 1, file);
	save_tree(file, model->forward);
	save_tree(file, model->backward);
	save_dictionary(file, model->dictionary);

	fclose(file);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Save_Tree
 *
 *		Purpose:		Save a tree structure to the specified file.
 */
void save_tree(FILE *file, TREE *node)
{
	static int level=0;
	register int i;

	fwrite(&(node->symbol), sizeof(BYTE2), 1, file);
	fwrite(&(node->usage), sizeof(BYTE4), 1, file);
	fwrite(&(node->count), sizeof(BYTE2), 1, file);
	fwrite(&(node->branch), sizeof(BYTE2), 1, file);

	if(level==0) progress("Saving tree", 0, 1);
	for(i=0; i<node->branch; ++i) {
		++level;
		save_tree(file, node->tree[i]);
		--level;
		if(level==0) progress(NULL, i, node->branch);
	}
	if(level==0) progress(NULL, 1, 1);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Load_Tree
 *
 *		Purpose:		Load a tree structure from the specified file.
 */
void load_tree(FILE *file, TREE *node)
{
	static int level=0;
	register int i;

	fread(&(node->symbol), sizeof(BYTE2), 1, file);
	fread(&(node->usage), sizeof(BYTE4), 1, file);
	fread(&(node->count), sizeof(BYTE2), 1, file);
	fread(&(node->branch), sizeof(BYTE2), 1, file);

	if(node->branch==0) return;

	node->tree=(TREE **)malloc(sizeof(TREE *)*(node->branch));
	if(node->tree==NULL) {
		error("load_tree", "Unable to allocate subtree");
		return;
	}

	if(level==0) progress("Loading tree", 0, 1);
	for(i=0; i<node->branch; ++i) {
		node->tree[i]=new_node();
		++level;
		load_tree(file, node->tree[i]);
		--level;
		if(level==0) progress(NULL, i, node->branch);
	}
	if(level==0) progress(NULL, 1, 1);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Load_Model
 *
 *		Purpose:		Load a model into memory.
 */
bool load_model(char *filename, MODEL *model)
{
	FILE *file;
	char cookie[16];

	if(filename==NULL) return(FALSE);

	file=fopen(filename, "rb");
	if(file==NULL) {
		warn("load_model", "Unable to open file `%s'", filename);
		return(FALSE);
	}

	fread(cookie, sizeof(char), strlen(COOKIE), file);
	if(strncmp(cookie, COOKIE, strlen(COOKIE))!=0) {
		warn("load_model", "File `%s' is not a MegaHAL brain", filename);
		goto fail;
	}

	fread(&(model->order), sizeof(BYTE1), 1, file);
	load_tree(file, model->forward);
	load_tree(file, model->backward);
	load_dictionary(file, model->dictionary);

	return(TRUE);
fail:
	fclose(file);

	return(FALSE);
}

/*---------------------------------------------------------------------------*/

/*
 *    Function:   Make_Words
 *
 *    Purpose:    Break a string into an array of words.
 */
void make_words(char *input, DICTIONARY *words)
{
	int offset=0;

	/*
	 *		Clear the entries in the dictionary
	 */
	free_dictionary(words);

	/*
	 *		If the string is empty then do nothing, for it contains no words.
	 */
	if(strlen(input)==0) return;

	/*
	 *		Loop forever.
	 */
	while(1) {

		/*
		 *		If the current character is of the same type as the previous
		 *		character, then include it in the word.  Otherwise, terminate
		 *		the current word.
		 */
		if(boundary(input, offset)) {
			/*
			 *		Add the word to the dictionary
			 */
			if(words->entry==NULL)
				words->entry=(STRING *)malloc((words->size+1)*sizeof(STRING));
			else
				words->entry=(STRING *)realloc(words->entry, (words->size+1)*sizeof(STRING));

			if(words->entry==NULL) {
				error("make_words", "Unable to reallocate dictionary");
				return;
			}

			words->entry[words->size].length=offset;
			words->entry[words->size].word=input;
			words->size+=1;

			if(offset==(int)strlen(input)) break;
			input+=offset;
			offset=0;
		} else {
			++offset;
		}
	}

	/*
	 *		If the last word isn't punctuation, then replace it with a
	 *		full-stop character.
	 */
	if(isalnum(words->entry[words->size-1].word[0])) {
		if(words->entry==NULL)
			words->entry=(STRING *)malloc((words->size+1)*sizeof(STRING));
		else
			words->entry=(STRING *)realloc(words->entry, (words->size+1)*sizeof(STRING));
		if(words->entry==NULL) {
			error("make_words", "Unable to reallocate dictionary");
			return;
		}

		words->entry[words->size].length=1;
		words->entry[words->size].word=".";
		++words->size;
	}
	else if(strchr("!.?", words->entry[words->size-1].word[words->entry[words->size-1].length-1])==NULL) {
		words->entry[words->size-1].length=1;
		words->entry[words->size-1].word=".";
	}

   return;
}
 
/*---------------------------------------------------------------------------*/ 
/*
 *		Function:	Boundary
 *
 *		Purpose:		Return whether or not a word boundary exists in a string
 *						at the specified location.
 */
bool boundary(char *string, int position)
{
	if(position==0)
		return(FALSE);

	if(position==(int)strlen(string))
		return(TRUE);

	if(
		(string[position]=='\'')&&
		(isalpha(string[position-1])!=0)&&
		(isalpha(string[position+1])!=0)
	)
		return(FALSE);

	if(
		(position>1)&&
		(string[position-1]=='\'')&&
		(isalpha(string[position-2])!=0)&&
		(isalpha(string[position])!=0)
	)
		return(FALSE);

	if(
		(isalpha(string[position])!=0)&&
		(isalpha(string[position-1])==0)
	)
		return(TRUE);
	
	if(
		(isalpha(string[position])==0)&&
		(isalpha(string[position-1])!=0)
	)
		return(TRUE);
	
	if(isdigit(string[position])!=isdigit(string[position-1]))
		return(TRUE);

	return(FALSE);
}
 
/*---------------------------------------------------------------------------*/ 
/*
 *		Function:	Make_Greeting
 *
 *		Purpose:		Put some special words into the dictionary so that the
 *						program will respond as if to a new judge.
 */
void make_greeting(DICTIONARY *words)
{
	register int i;

	for(i=0; i<words->size; ++i) free(words->entry[i].word);
	free_dictionary(words);
	if(grt->size>0) (void)add_word(words, grt->entry[rnd(grt->size)]);
}
 
/*---------------------------------------------------------------------------*/ 
/*
 *    Function:   Generate_Reply
 *
 *    Purpose:    Take a string of user input and return a string of output
 *                which may vaguely be construed as containing a reply to
 *                whatever is in the input string.
 */
char *generate_reply(MODEL *model, DICTIONARY *words)
{
	static DICTIONARY *dummy=NULL;
	DICTIONARY *replywords;
	DICTIONARY *keywords;
	float surprise;
	float max_surprise;
	char *output;
	static char *output_none=NULL;
	int count;
	int basetime;

	/*
	 *		Create an array of keywords from the words in the user's input
	 */
	keywords=make_keywords(model, words);

	/*
	 *		Make sure some sort of reply exists
	 */
	if(output_none==NULL) {
		output_none=malloc(40);
		if(output_none!=NULL)
			strcpy(output_none, "I don't know enough to answer you yet!");
	}
	output=output_none;
	if(dummy==NULL) dummy=new_dictionary();
	replywords=reply(model, dummy);
	if(dissimilar(words, replywords)==TRUE) output=make_output(replywords);

	/*
	 *		Loop for the specified waiting period, generating and evaluating
	 *		replies
	 */
	max_surprise=(float)-1.0;
	count=0;
	basetime=time(NULL);
	progress("Generating reply", 0, 1);
	do {
		replywords=reply(model, keywords);
		surprise=evaluate_reply(model, keywords, replywords);
		++count;
		if((surprise>max_surprise)&&(dissimilar(words, replywords)==TRUE)) {
			max_surprise=surprise;
			output=make_output(replywords);
		}
		progress(NULL, (time(NULL)-basetime),timeout);
	} while((time(NULL)-basetime)<timeout);
	progress(NULL, 1, 1);

	/*
	 *		Return the best answer we generated
	 */
	return(output);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Dissimilar
 *
 *		Purpose:		Return TRUE or FALSE depending on whether the dictionaries
 *						are the same or not.
 */
bool dissimilar(DICTIONARY *words1, DICTIONARY *words2)
{
	register int i;

	if(words1->size!=words2->size) return(TRUE);
	for(i=0; i<words1->size; ++i)
		if(wordcmp(words1->entry[i], words2->entry[i])!=0) return(TRUE);
	return(FALSE);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Make_Keywords
 *
 *		Purpose:		Put all the interesting words from the user's input into
 *						a keywords dictionary, which will be used when generating
 *						a reply.
 */
DICTIONARY *make_keywords(MODEL *model, DICTIONARY *words)
{
	static DICTIONARY *keys=NULL;
	register int i;
	register int j;
	int c;

	if(keys==NULL) keys=new_dictionary();
	for(i=0; i<keys->size; ++i) free(keys->entry[i].word);
	free_dictionary(keys);

	for(i=0; i<words->size; ++i) {
		/*
		 *		Find the symbol ID of the word.  If it doesn't exist in
		 *		the model, or if it begins with a non-alphanumeric
		 *		character, or if it is in the exclusion array, then
		 *		skip over it.
		 */
		c=0;
		for(j=0; j<swp->size; ++j)
			if(wordcmp(swp->from[j], words->entry[i])==0) {
				add_key(model, keys, swp->to[j]);
				++c;
			}
		if(c==0) add_key(model, keys, words->entry[i]);
	}

	if(keys->size>0) for(i=0; i<words->size; ++i) {

		c=0;
		for(j=0; j<swp->size; ++j)
			if(wordcmp(swp->from[j], words->entry[i])==0) {
				add_aux(model, keys, swp->to[j]);
				++c;
			}
		if(c==0) add_aux(model, keys, words->entry[i]);
	}

	return(keys);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Add_Key
 *
 *		Purpose:		Add a word to the keyword dictionary.
 */
void add_key(MODEL *model, DICTIONARY *keys, STRING word)
{
	int symbol;

	symbol=find_word(model->dictionary, word);
	if(symbol==0) return;
	if(isalnum(word.word[0])==0) return;
	symbol=find_word(ban, word);
	if(symbol!=0) return;
	symbol=find_word(aux, word);
	if(symbol!=0) return;

	add_word(keys, word);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Add_Aux
 *
 *		Purpose:		Add an auxilliary keyword to the keyword dictionary.
 */
void add_aux(MODEL *model, DICTIONARY *keys, STRING word)
{
	int symbol;

	symbol=find_word(model->dictionary, word);
	if(symbol==0) return;
	if(isalnum(word.word[0])==0) return;
	symbol=find_word(aux, word);
	if(symbol==0) return;

	add_word(keys, word);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Reply
 *
 *		Purpose:		Generate a dictionary of reply words appropriate to the
 *						given dictionary of keywords.
 */
DICTIONARY *reply(MODEL *model, DICTIONARY *keys)
{
	static DICTIONARY *replies=NULL;
	register int i;
	int symbol;
	bool start=TRUE;

	if(replies==NULL) replies=new_dictionary();
	free_dictionary(replies);

	/*
	 *		Start off by making sure that the model's context is empty.
	 */
	initialize_context(model);
	model->context[0]=model->forward;
	used_key=FALSE;

	/*
	 *		Generate the reply in the forward direction.
	 */
	while(TRUE) {
		/*
		 *		Get a random symbol from the current context.
		 */
		if(start==TRUE) symbol=seed(model, keys);
		else symbol=babble(model, keys, replies);
		if((symbol==0)||(symbol==1)) break;
		start=FALSE;

		/*
		 *		Append the symbol to the reply dictionary.
		 */
		if(replies->entry==NULL)
			replies->entry=(STRING *)malloc((replies->size+1)*sizeof(STRING));
		else
			replies->entry=(STRING *)realloc(replies->entry, (replies->size+1)*sizeof(STRING));
		if(replies->entry==NULL) {
			error("reply", "Unable to reallocate dictionary");
			return(NULL);
		}

		replies->entry[replies->size].length=
			model->dictionary->entry[symbol].length;
		replies->entry[replies->size].word=
			model->dictionary->entry[symbol].word;
		replies->size+=1;

		/*
		 *		Extend the current context of the model with the current symbol.
		 */
		update_context(model, symbol);
	}

	/*
	 *		Start off by making sure that the model's context is empty.
	 */
	initialize_context(model);
	model->context[0]=model->backward;

	/*
	 *		Re-create the context of the model from the current reply
	 *		dictionary so that we can generate backwards to reach the
	 *		beginning of the string.
	 */
	if(replies->size>0) for(i=MIN(replies->size-1, model->order); i>=0; --i) {
		symbol=find_word(model->dictionary, replies->entry[i]);
		update_context(model, symbol);
	}

	/*
	 *		Generate the reply in the backward direction.
	 */
	while(TRUE) {
		/*
		 *		Get a random symbol from the current context.
		 */
		symbol=babble(model, keys, replies);
		if((symbol==0)||(symbol==1)) break;

		/*
		 *		Prepend the symbol to the reply dictionary.
		 */
		if(replies->entry==NULL)
			replies->entry=(STRING *)malloc((replies->size+1)*sizeof(STRING));
		else
			replies->entry=(STRING *)realloc(replies->entry, (replies->size+1)*sizeof(STRING));
		if(replies->entry==NULL) {
			error("reply", "Unable to reallocate dictionary");
			return(NULL);
		}

		/*
		 *		Shuffle everything up for the prepend.
		 */
		for(i=replies->size; i>0; --i) {
			replies->entry[i].length=replies->entry[i-1].length;
			replies->entry[i].word=replies->entry[i-1].word;
		}

		replies->entry[0].length=model->dictionary->entry[symbol].length;
		replies->entry[0].word=model->dictionary->entry[symbol].word;
		replies->size+=1;

		/*
		 *		Extend the current context of the model with the current symbol.
		 */
		update_context(model, symbol);
	}

	return(replies);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Evaluate_Reply
 *
 *		Purpose:		Measure the average surprise of keywords relative to the
 *						language model.
 */
float evaluate_reply(MODEL *model, DICTIONARY *keys, DICTIONARY *words)
{
	register int i;
	register int j;
	int symbol;
	float probability;
	int count;
	float entropy=(float)0.0;
	TREE *node;
	int num=0;

	if(words->size<=0) return((float)0.0);
	initialize_context(model);
	model->context[0]=model->forward;
	for(i=0; i<words->size; ++i) {
		symbol=find_word(model->dictionary, words->entry[i]);

		if(find_word(keys, words->entry[i])!=0) {
			probability=(float)0.0;
			count=0;
			++num;
			for(j=0; j<model->order; ++j) if(model->context[j]!=NULL) {
	
				node=find_symbol(model->context[j], symbol);
				probability+=(float)(node->count)/
					(float)(model->context[j]->usage);
				++count;
	
			}

			if(count>0.0) entropy-=(float)log(probability/(float)count);
		}

		update_context(model, symbol);
	}

	initialize_context(model);
	model->context[0]=model->backward;
	for(i=words->size-1; i>=0; --i) {
		symbol=find_word(model->dictionary, words->entry[i]);

		if(find_word(keys, words->entry[i])!=0) {
			probability=(float)0.0;
			count=0;
			++num;
			for(j=0; j<model->order; ++j) if(model->context[j]!=NULL) {
	
				node=find_symbol(model->context[j], symbol);
				probability+=(float)(node->count)/
					(float)(model->context[j]->usage);
				++count;
	
			}

			if(count>0.0) entropy-=(float)log(probability/(float)count);
		}

		update_context(model, symbol);
	}

	if(num>=8) entropy/=(float)sqrt(num-1);
	if(num>=16) entropy/=(float)num;

	return(entropy);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Make_Output
 *
 *		Purpose:		Generate a string from the dictionary of reply words.
 */
char *make_output(DICTIONARY *words)
{
	static char *output=NULL;
	register int i;
	register int j;
	int length;
	static char *output_none=NULL;
	
	if(output_none==NULL) output_none=malloc(40);

	if(output==NULL) {
		output=(char *)malloc(sizeof(char));
		if(output==NULL) {
			error("make_output", "Unable to allocate output");
			return(output_none);
		}
	}

	if(words->size==0) {
		if(output_none!=NULL)
			strcpy(output_none, "I am utterly speechless!");
		return(output_none);
	}

	length=1;
	for(i=0; i<words->size; ++i) length+=words->entry[i].length;

	output=(char *)realloc(output, sizeof(char)*length);
	if(output==NULL) {
		error("make_output", "Unable to reallocate output.");
		if(output_none!=NULL)
			strcpy(output_none, "I forgot what I was going to say!");
		return(output_none);
	}

	length=0;
	for(i=0; i<words->size; ++i)
		for(j=0; j<words->entry[i].length; ++j)
			output[length++]=words->entry[i].word[j];
			
	output[length]='\0';

	return(output);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Babble
 *
 *		Purpose:		Return a random symbol from the current context, or a
 *						zero symbol identifier if we've reached either the
 *						start or end of the sentence.  Select the symbol based
 *						on probabilities, favouring keywords.  In all cases,
 *						use the longest available context to choose the symbol.
 */
int babble(MODEL *model, DICTIONARY *keys, DICTIONARY *words)
{
	TREE *node;
	register int i;
	int count;
	int symbol;

	/*
	 *		Select the longest available context.
	 */
	for(i=0; i<=model->order; ++i)
		if(model->context[i]!=NULL)
			node=model->context[i];

	if(node->branch==0) return(0);

	/*
	 *		Choose a symbol at random from this context.
	 */
	i=rnd(node->branch);
	count=rnd(node->usage);
	while(count>=0) {
		/*
		 *		If the symbol occurs as a keyword, then use it.  Only use an
		 *		auxilliary keyword if a normal keyword has already been used.
		 */
		symbol=node->tree[i]->symbol;

		if(
			(find_word(keys, model->dictionary->entry[symbol])!=0)&&
			((used_key==TRUE)||
			(find_word(aux, model->dictionary->entry[symbol])==0))&&
			(word_exists(words, model->dictionary->entry[symbol])==FALSE)
		) {
			used_key=TRUE;
			break;
		}
		count-=node->tree[i]->count;
		i=(i>=(node->branch-1))?0:i+1;
	}

	return(symbol);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Word_Exists
 *
 *		Purpose:		A silly brute-force searcher for the reply string.
 */
bool word_exists(DICTIONARY *dictionary, STRING word)
{
	register int i;

	for(i=0; i<dictionary->size; ++i)
		if(wordcmp(dictionary->entry[i], word)==0)
			return(TRUE);
	return(FALSE);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Seed
 *
 *		Purpose:		Seed the reply by guaranteeing that it contains a
 *						keyword, if one exists.
 */
int seed(MODEL *model, DICTIONARY *keys)
{
	register int i;
	int symbol;
	int stop;

	/*
	 *		Fix, thanks to Mark Tarrabain
	 */
	if(model->context[0]->branch==0) symbol=0;
	else symbol=model->context[0]->tree[rnd(model->context[0]->branch)]->symbol;

	if(keys->size>0) {
		i=rnd(keys->size);
		stop=i;
		while(TRUE) {
			if(
				(find_word(model->dictionary, keys->entry[i])!=0)&&
				(find_word(aux, keys->entry[i])==0)
			) {
				symbol=find_word(model->dictionary, keys->entry[i]);
				return(symbol);
			}
			++i;
			if(i==keys->size) i=0;
			if(i==stop) return(symbol);
		}
	}

	return(symbol);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	New_Swap
 *
 *		Purpose:		Allocate a new swap structure.
 */
SWAP *new_swap(void)
{
	SWAP *list;

	list=(SWAP *)malloc(sizeof(SWAP));
	if(list==NULL) {
		error("new_swap", "Unable to allocate swap");
		return(NULL);
	}
	list->size=0;
	list->from=NULL;
	list->to=NULL;

	return(list);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Add_Swap
 *
 *		Purpose:		Add a new entry to the swap structure.
 */
void add_swap(SWAP *list, char *s, char *d)
{
	list->size+=1;

	if(list->from==NULL) {
		list->from=(STRING *)malloc(sizeof(STRING));
		if(list->from==NULL) {
			error("add_swap", "Unable to allocate list->from");
			return;
		}
	}

	if(list->to==NULL) {
		list->to=(STRING *)malloc(sizeof(STRING));
		if(list->to==NULL) {
			error("add_swap", "Unable to allocate list->to");
			return;
		}
	}

	list->from=(STRING *)realloc(list->from, sizeof(STRING)*(list->size));
	if(list->from==NULL) {
		error("add_swap", "Unable to reallocate from");
		return;
	}

	list->to=(STRING *)realloc(list->to, sizeof(STRING)*(list->size));
	if(list->to==NULL) {
		error("add_swap", "Unable to reallocate to");
		return;
	}

	list->from[list->size-1].length=strlen(s);
	list->from[list->size-1].word=strdup(s);
	list->to[list->size-1].length=strlen(d);
	list->to[list->size-1].word=strdup(d);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Initialize_Swap
 *
 *		Purpose:		Read a swap structure from a file.
 */
SWAP *initialize_swap(char *filename)
{
	SWAP *list;
	FILE *file=NULL;
	char buffer[1024];
	char *from;
	char *to;

	list=new_swap();

	if(filename==NULL) return(list);

	file=fopen(filename, "r");
	if(file==NULL) return(list);

	while(!feof(file)) {

		if(fgets(buffer, 1024, file)==NULL) break;
		if(buffer[0]=='#') continue;
		from=strtok(buffer, "\t ");
		to=strtok(NULL, "\t \n#");

		add_swap(list, from, to);
	}

	fclose(file);
	return(list);
}

/*---------------------------------------------------------------------------*/

void free_swap(SWAP *swap)
{
	register int i;

	if(swap==NULL) return;

	for(i=0; i<swap->size; ++i) {
		free_word(swap->from[i]);
		free_word(swap->to[i]);
	}
	free(swap->from);
	free(swap->to);
	free(swap);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Initialize_List
 *
 *		Purpose:		Read a dictionary from a file.
 */
DICTIONARY *initialize_list(char *filename)
{
	DICTIONARY *list;
	FILE *file=NULL;
	STRING word;
	char *string;
	char buffer[1024];

	list=new_dictionary();

	if(filename==NULL) return(list);

	file=fopen(filename, "r");
	if(file==NULL) return(list);

	while(!feof(file)) {

		if(fgets(buffer, 1024, file)==NULL) break;
		if(buffer[0]=='#') continue;
		string=strtok(buffer, "\t \n#");

		if((string!=NULL)&&(strlen(string)>0)) {
			word.length=strlen(string);
			word.word=strdup(buffer);
			add_word(list, word);
		}
	}

	fclose(file);
	return(list);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Delay
 *
 *		Purpose:		Display the string to stdout as if it was typed by a human.
 */
void delay(char *string)
{
	register int i;
	
	/*
	 *		Don't simulate typing if the feature is turned off
	 */
	if(typing_delay==FALSE)	{
		fprintf(stdout, string);
		return;
	}

	/*
	 *		Display the entire string, one character at a time
	 */
	for(i=0; i<(int)strlen(string)-1; ++i) typein(string[i]);
	usleep((D_THINK+rnd(V_THINK)-rnd(V_THINK))/2);
	typein(string[i]);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Typein
 *
 *		Purpose:		Display a character to stdout as if it was typed by a human.
 */
void typein(char c)
{
	/*
	 *		Standard keyboard delay
	 */
	usleep(D_KEY+rnd(V_KEY)-rnd(V_KEY));
	fprintf(stdout, "%c", c);
	fflush(stdout);
	
	/*
	 *		A random thinking delay
	 */
	if((!isalnum(c))&&((rnd(100))<P_THINK))
		usleep(D_THINK+rnd(V_THINK)-rnd(V_THINK));
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Ignore
 *
 *		Purpose:		Log the occurrence of a signal, but ignore it.
 */
void ignore(int sig)
{
	if(sig!=0) warn("ignore", "MegaHAL received signal %d", sig);

#if !defined(DOS)
	signal(SIGINT, ignore);
	signal(SIGILL, die);
	signal(SIGSEGV, die);
#endif
	signal(SIGFPE, die);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Die
 *
 *		Purpose:		Log the occurrence of a signal, and exit.
 */
void die(int sig)
{
	error("die", "MegaHAL received signal %d", sig);
	exithal();
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Rnd
 *
 *		Purpose:		Return a random integer between 0 and range-1.
 */
int rnd(int range)
{
	static bool flag=FALSE;

	if(flag==FALSE) {
#if defined(__mac_os) || defined(DOS)
		srand(time(NULL));
#else
		srand48(time(NULL));
#endif
	}
	flag=TRUE;
#if defined(__mac_os) || defined(DOS)
	return(rand()%range);
#else
	return(floor(drand48()*(double)(range)));
#endif
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Usleep
 *
 *		Purpose:		Simulate the Un*x function usleep.  Necessary because
 *						Microsoft provide no similar function.  Performed via
 *						a busy loop, which unnecessarily chews up the CPU.
 *						But Windows '95 isn't properly multitasking anyway, so
 *						no-one will notice.  Modified from a real Microsoft
 *						example, believe it or not!
 */
#if defined(DOS) || defined(__mac_os)
void usleep(int period)
{
	clock_t goal;

	goal=(clock_t)(period*CLOCKS_PER_SEC)/(clock_t)1000000+clock();
	while(goal>clock());
}
#endif

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Strdup
 *
 *		Purpose:		Provide the strdup() function for Macintosh.
 */
#ifdef __mac_os
char *strdup(const char *str)
{
	char *rval=(char *)malloc(strlen(str)+1);

	if(rval!=NULL) strcpy(rval, str);

	return(rval);
}
#endif

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Initialize_Speech
 *
 *		Purpose:		Initialize speech output.
 */
#ifdef __mac_os
bool initialize_speech(void)
{
	bool speechExists = false;
	long response;
	OSErr err;

	err = Gestalt(gestaltSpeechAttr, &response);
        
	if(!err) {
		if(response & (1L << gestaltSpeechMgrPresent)) {
			speechExists = true;
		}
	}
	return speechExists;
}
#endif

/*---------------------------------------------------------------------------*/

/*
 *		Function:	changevoice
 *
 *		Purpose:		change voice of speech output.
 */
void changevoice(DICTIONARY* words, int position)
{
#ifdef __mac_os
	register int i, index;
	STRING word={ 1, "#" };
	char buffer[80];
	VoiceSpec voiceSpec;
	VoiceDescription info;
	short count, voiceCount;
	unsigned char* temp;
	OSErr err;
	/*
	 *		If there is less than 4 words, no voice specified.
	 */
	if(words->size<=4) return;

	for(i=0; i<words->size-4; ++i)
		if(wordcmp(word, words->entry[i])==0) {

		err = CountVoices(&voiceCount);
		if (!err && voiceCount) {
			for (count = 1; count <= voiceCount; count++) {
				err = GetIndVoice(count, &voiceSpec);
				if (err) continue;
				err = GetVoiceDescription(&voiceSpec, &info, 
sizeof(VoiceDescription));
				if (err) continue;


				for (temp= info.name; *temp; temp++) {
					if (*temp == ' ')
						*temp = '_';
				}

				/*
				 *		skip command and get voice name
				 */
				index = i + 3;
				strcpy(buffer, words->entry[index].word);
				c2pstr(buffer);
				// compare ignoring case
				if (EqualString((StringPtr)buffer, info.name, false, false)) {
					if (gSpeechChannel) {
						StopSpeech(gSpeechChannel);
						DisposeSpeechChannel(gSpeechChannel);
						gSpeechChannel = nil;
					}
					err = NewSpeechChannel(&voiceSpec, &gSpeechChannel);
					if (!err) {
						p2cstr((StringPtr)buffer);
						printf("Now using %s voice\n", buffer);
						c2pstr(buffer);
						err = SpeakText(gSpeechChannel, &buffer[1], buffer[0]);
					}
				}
			}
		}
	}
#endif
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	listvoices
 *
 *		Purpose:		Display the names of voices for speech output.
 */
void listvoices(void)
{
#ifdef __mac_os
	VoiceSpec voiceSpec;
	VoiceDescription info;
	short count, voiceCount;
	unsigned char* temp;
	OSErr err;

	if(gSpeechExists) {
		err = CountVoices(&voiceCount);
		if (!err && voiceCount) {
			for (count = 1; count <= voiceCount; count++) {
				err = GetIndVoice(count, &voiceSpec);
				if (err) continue;

				err = GetVoiceDescription(&voiceSpec, &info, 
sizeof(VoiceDescription));
				if (err) continue;

				p2cstr(info.name);
				for (temp= info.name; *temp; temp++)
				if (*temp == ' ')
					*temp = '_';
				printf("%s\n",info.name);
			}
		}
	}
#endif
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Speak
 */
void speak(char *output)
{
	if(speech==FALSE) return;
#ifdef __mac_os
	if(gSpeechExists) {
		OSErr err;

		if (gSpeechChannel)
			err = SpeakText(gSpeechChannel, output, strlen(output));
		else {
			c2pstr(output);
			SpeakString((StringPtr)output);
			p2cstr((StringPtr)output);
		}
	}
#endif
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Progress
 *
 *		Purpose:		Display a progress indicator as a percentage.
 */
bool progress(char *message, int done, int total)
{
	static int last=0;
	static bool first=FALSE;

	if(prog==FALSE) return(TRUE);
 
	/*
	 *    We have already hit 100%, and a newline has been printed, so nothing
	 *    needs to be done.
	 */
	if((done*100/total==100)&&(first==FALSE)) return(TRUE);

	/*
	 *    Nothing has changed since the last time this function was called,
	 *    so do nothing, unless it's the first time!
	 */
	if(done*100/total==last) {
		if((done==0)&&(first==FALSE)) {
			fprintf(stderr, "%s: %3d%%", message, done*100/total);
			first=TRUE;
		}
		return(TRUE);
	}

	/*
	 *    Erase what we printed last time, and print the new percentage.
	 */
	last=done*100/total;

	if(done>0) fprintf(stderr, "%c%c%c%c", 8, 8, 8, 8);
	fprintf(stderr, "%3d%%", done*100/total);

	/*
	 *    We have hit 100%, so reset static variables and print a newline.
	 */
	if(last==100) {
		first=FALSE;
		last=0;
		fprintf(stderr, "\n");
	}

	return(TRUE);
}

/*---------------------------------------------------------------------------*/

void help(void)
{
	int j;

	for(j=0; j<COMMAND_SIZE; ++j) {
		printf("#%-7s: %s\n", command[j].word.word, command[j].helpstring);
	}
}

/*---------------------------------------------------------------------------*/

void load_personality(MODEL **model)
{
	FILE *file;
	static char *filename=NULL;

	if(filename==NULL) filename=(char *)malloc(sizeof(char)*1);

	/*
	 *		Allocate memory for the filename
	 */
	filename=(char *)realloc(filename,
		sizeof(char)*(strlen(directory)+strlen(SEP)+12));
	if(filename==NULL) error("load_personality","Unable to allocate filename");

	/*
	 *		Check to see if the brain exists
	 */
	if(strcmp(directory, DEFAULT)!=0) {
	sprintf(filename, "%s%smegahal.brn", directory, SEP);
	file=fopen(filename, "r");
	if(file==NULL) {
		sprintf(filename, "%s%smegahal.trn", directory, SEP);
		file=fopen(filename, "r");
		if(file==NULL) {
			fprintf(stdout, "Unable to change MegaHAL personality to \"%s\".\n"
				"Reverting to MegaHAL personality \"%s\".\n", directory, last);
			free(directory);
			directory=strdup(last);
			return;
		}
	}
	fclose(file);
	fprintf(stdout, "Changing to MegaHAL personality \"%s\".\n", directory);
	}

	/*
	 *		Free the current personality
	 */
	free_model(*model);
	free_words(ban);
	free_dictionary(ban);
	free_words(aux);
	free_dictionary(aux);
	free_words(grt);
	free_dictionary(grt);
	free_swap(swp);

	/*
	 *		Create a language model.
	 */
	*model=new_model(order);

	/*
	 *		Train the model on a text if one exists
	 */
	sprintf(filename, "%s%smegahal.brn", directory, SEP);
	if(load_model(filename, *model)==FALSE) {
		sprintf(filename, "%s%smegahal.trn", directory, SEP);
		train(*model, filename);
	}

	/*
	 *		Read a dictionary containing banned keywords, auxiliary keywords,
	 *		greeting keywords and swap keywords
	 */
	sprintf(filename, "%s%smegahal.ban", directory, SEP);
	ban=initialize_list(filename);
	sprintf(filename, "%s%smegahal.aux", directory, SEP);
	aux=initialize_list(filename);
	sprintf(filename, "%s%smegahal.grt", directory, SEP);
	grt=initialize_list(filename);
	sprintf(filename, "%s%smegahal.swp", directory, SEP);
	swp=initialize_swap(filename);
}

/*---------------------------------------------------------------------------*/

void change_personality(DICTIONARY *command, int position, MODEL **model)
{
	if(last!=NULL) { free(last); last=NULL; }
	if(directory!=NULL) last=strdup(directory);
	else directory=(char *)malloc(sizeof(char)*1);
	if(directory==NULL)
		error("change_personality", "Unable to allocate directory");
	if((command==NULL)||((position+2)>=command->size)) {
		directory=(char *)realloc(directory, sizeof(char)*(strlen(DEFAULT)+1));
		if(directory==NULL)
			error("change_personality", "Unable to allocate directory");
		strcpy(directory, DEFAULT);
		if(last==NULL) last=strdup(directory);
	} else {
		directory=(char *)realloc(directory,
			sizeof(char)*(command->entry[position+2].length+1));
		if(directory==NULL)
			error("change_personality", "Unable to allocate directory");
		strncpy(directory, command->entry[position+2].word,
			command->entry[position+2].length);
		directory[command->entry[position+2].length]='\0';
	}

	load_personality(model);
}

/*---------------------------------------------------------------------------*/

void change_think(DICTIONARY *command, int position)
{
	printf("Changing thinking delay not yet supported\n");	
	/*
	if((command==NULL)||((position+2)>=command->size)) {

	command->entry[position+2].word
	command->entry[position+2].length
	*/
}

/*---------------------------------------------------------------------------*/

void free_words(DICTIONARY *words)
{
	register int i;

	if(words==NULL) return;

	if(words->entry!=NULL)
		for(i=0; i<words->size; ++i) free_word(words->entry[i]);
}

/*---------------------------------------------------------------------------*/

void free_word(STRING word)
{
	free(word.word);
}

/*===========================================================================*/
/*
 *		$Log: megahal.c,v $
 * Revision 1.24  1998/09/03  03:07:09  hutch
 * Don't know.
 *
 *		Revision 1.23  1998/05/19 03:02:02  hutch
 *		Removed a small malloc() bug, and added a progress display for
 *		generate_reply().
 *
 *		Revision 1.22  1998/04/24 03:47:03  hutch
 *		Quick bug fix to get sunos version to work.
 *
 *		Revision 1.21  1998/04/24 03:39:51  hutch
 *		Added the BRAIN command, to allow user to change MegaHAL personalities
 *		on the fly.
 *
 *		Revision 1.20  1998/04/22 07:12:37  hutch
 *		A few small changes to get the DOS version to compile.
 *
 *		Revision 1.19  1998/04/21 10:10:56  hutch
 *		Fixed a few little errors.
 *
 *		Revision 1.18  1998/04/06 08:02:01  hutch
 *		Added debugging stuff, courtesy of Paul Baxter.
 *
 *		Revision 1.17  1998/04/02 01:34:20  hutch
 *		Added the help function and fixed a few errors.
 *
 *		Revision 1.16  1998/04/01 05:42:57  hutch
 *		Incorporated Mac code, including speech synthesis, and attempted
 *		to tidy up the code for multi-platform support.
 *
 *		Revision 1.15  1998/03/27 03:43:15  hutch
 *		Added AMIGA specific changes, thanks to Dag Agren.
 *
 *		Revision 1.14  1998/02/20 06:40:13  hutch
 *		Tidied up transcript file format.
 *
 *		Revision 1.13  1998/02/20 06:26:19  hutch
 *		Fixed random number generator and Seed() function (thanks to Mark
 *		Tarrabain), removed redundant code left over from the Loebner entry,
 *		prettied things up a little and destroyed several causes of memory
 *		leakage (although probably not all).
 *
 *		Revision 1.12  1998/02/04 02:55:11  hutch
 *		Fixed up memory allocation error which caused SunOS versions to crash.
 *
 *		Revision 1.11  1998/01/22 03:16:30  hutch
 *		Fixed several memory leaks, and the frustrating bug in the
 *		Write_Input routine.
 *
 *		Revision 1.10  1998/01/19 06:44:36  hutch
 *		Fixed MegaHAL to compile under Linux with a small patch credited
 *		to Joey Hess (joey@@kitenet.net).  MegaHAL may now be included as
 *		part of the Debian Linux distribution.
 *
 *		Revision 1.9  1998/01/19 06:37:32  hutch
 *		Fixed a minor bug with end-of-sentence punctuation.
 *
 *		Revision 1.8  1997/12/24 03:17:01  hutch
 *		More bug fixes, and hopefully the final contest version!
 *
 *		Revision 1.7  1997/12/22  13:18:09  hutch
 *		A few more bug fixes, and non-repeating implemented.
 *
 *		Revision 1.6  1997/12/22 04:27:04  hutch
 *		A few minor bug fixes.
 *
 *		Revision 1.5  1997/12/15 04:35:59  hutch
 *		Final Loebner version!
 *
 *		Revision 1.4  1997/12/11 05:45:29  hutch
 *		The almost finished version.
 *
 *		Revision 1.3  1997/12/10 09:08:09  hutch
 *		Now Loebner complient (tm).
 *
 *		Revision 1.2  1997/12/08 06:22:32  hutch
 *		Tidied up.
 *
 *		Revision 1.1  1997/12/05  07:11:44  hutch
 *		Initial revision (lots of files were merged into one, RCS re-started)
 *
 *		Revision 1.7  1997/12/04 07:07:13  hutch
 *		Added load and save functions, and tidied up some code.
 *
 *		Revision 1.6  1997/12/02 08:34:47  hutch
 *		Added the ban, aux and swp functions.
 *
 *		Revision 1.5  1997/12/02 06:03:04  hutch
 *		Updated to use a special terminating symbol, and to store only
 *		branches of maximum depth, as they are the only ones used in
 *		the reply.
 *
 *		Revision 1.4  1997/10/28 09:23:12  hutch
 *		MegaHAL is babbling nicely, but without keywords.
 *
 *		Revision 1.3  1997/10/15  09:04:03  hutch
 *		MegaHAL can parrot back whatever the user says.
 *
 *		Revision 1.2  1997/07/21 04:03:28  hutch
 *		Fully working.
 *
 *		Revision 1.1  1997/07/15 01:55:25  hutch
 *		Initial revision.
 */
/*===========================================================================*/
@


1.24
log
@Don't know.
@
text
@a0 1

a1 1

d3 1
a3 1
 *  Copyright (C) 1998 Jason Hutchens
a18 1

a19 1

d21 1
a21 1
 *		$Id: megahal.c,v 1.23 1998/05/19 03:02:02 hutch Exp hutch $
a113 1

d240 2
a241 2
FILE *errorfp=stderr;
FILE *statusfp=stdout;
d563 1
a563 1
	if(errorfp!=stderr) fclose(errorfp);
a566 1
		errorfp=stderr;
d583 15
a597 6
	fprintf(errorfp, "%s: ", title);
	va_start(argp, fmt);
	vfprintf(errorfp, fmt, argp);
	va_end(argp);
	fprintf(errorfp, ".\n");
	fflush(errorfp);
d610 15
a624 6
	fprintf(errorfp, "%s: ", title);
	va_start(argp, fmt);
	vfprintf(errorfp, fmt, argp);
	va_end(argp);
	fprintf(errorfp, ".\n");
	fflush(errorfp);
d640 1
a640 1
	if(statusfp!=stdout) fclose(statusfp);
a643 1
		statusfp=stdout;
d660 11
a670 4
	va_start(argp, fmt);
	vfprintf(statusfp, fmt, argp);
	va_end(argp);
	fflush(statusfp);
a3160 1

d3163 3
a3266 1

a3267 1

@


1.23
log
@Removed a small malloc() bug, and added a progress display for
generate_reply().
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.22 1998/04/24 03:47:03 hutch Exp hutch $
d54 8
a61 1
 *		Notes:		This file is best viewed with tabstops set to three spaces.
d90 3
a92 3
 *		PC (Linux)
 *		----------
 *		Jason Hutchens (hutch@@ciips.ee.uwa.edu.au)
d100 1
d156 1
d239 1
d252 5
a257 1
	{ { 4, "EXIT" }, "exits the program *without* saving MegaHAL's brain", EXIT },
a258 1
	{ { 5, "DELAY" }, "toggles MegaHAL's typing delay (off by default)", DELAY },
d260 1
a260 1
	{ { 6, "VOICES" }, "list available voices for speech", VOICELIST },
d262 1
a262 2
	{ { 5, "BRAIN" }, "change to another MegaHAL personality", BRAIN },
	{ { 4, "HELP" }, "displays this message", HELP }
d377 7
d2953 2
d3112 13
d3146 4
@


1.22
log
@Quick bug fix to get sunos version to work.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.21 1998/04/24 03:39:51 hutch Exp hutch $
d29 1
a29 1
 *		Program:		MegaHAL v8r5
d146 1
a146 1
void changevoice(DICTIONARY *);
d302 1
a302 1
"|  #    #  ######   ####   #    #  #    #  #    #  ######    #     ###r5 |\n"
d357 1
a357 1
				changevoice(words);
d1974 1
d1983 1
d1985 1
d2801 1
a2801 1
void changevoice(DICTIONARY* words)
d2803 1
d2806 1
a2806 1
 #ifdef __mac_os
a2811 1
	char buffer[80];
d3071 1
a3071 1
		directory=(char *)realloc(directory, sizeof(char)*strlen(DEFAULT));
d3112 3
@


1.21
log
@Added the BRAIN command, to allow the user to change MegaHAL personalits
on the fly.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.20 1998/04/22 07:12:37 hutch Exp hutch $
d1652 2
a2930 1
	static char command[1024];
d2988 2
d3064 3
d3109 4
@


1.20
log
@A few small changes to get the DOS version to compile.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.19 1998/04/21 10:10:56 hutch Exp hutch $
d147 1
d153 1
a153 1
COMMAND_WORDS execute_command(DICTIONARY *);
d158 1
d160 4
a163 1
char *format_output(char *);
d180 1
d238 2
d249 1
d277 1
d279 1
d285 1
a293 25
	/*
	 *		Create a dictionary which will be used to hold the segmented
	 *		version of the user's input.
	 */
	words=new_dictionary();

	/*
	 *		Create a language model.
	 */
	model=new_model(order);

	/*
	 *		Train the model on a text if one exists
	 */
	if(load_model("megahal.brn", model)==FALSE) train(model, "megahal.trn");

	/*
	 *		Read a dictionary containing banned keywords, auxiliary keywords,
	 *		greeting keywords and swap keywords
	 */
	ban=initialize_list("megahal.ban");
	aux=initialize_list("megahal.aux");
	grt=initialize_list("megahal.grt");
	swp=initialize_swap("megahal.swp");

d309 14
a324 4
	initialize_status("megahal.txt");
	make_greeting(words);
	output=generate_reply(model, words);
	write_output(output);
a327 1
		upper(input);
a328 1
		learn(model, words);
d333 1
a333 1
		switch(execute_command(words)) {
a335 1
				break;
a338 1
				break;
a341 1
				break;
a345 1
				break;
a349 1
				break;
a352 1
				break;
a355 1
				break;
d359 6
a364 1
				break;
d369 3
d391 1
a391 1
COMMAND_WORDS execute_command(DICTIONARY *words)
a394 1
	STRING word={ 1, "#" };
d399 1
d413 1
a413 1
		if(wordcmp(word, words->entry[i])==0) {
d418 2
a419 1
				if(wordcmp(command[j].word, words->entry[i+1])==0)
d421 1
a998 9
/*
 *		strncmp() doesn't behave identically to wordcmp(), so I've commented
 *		this code out - Jas.
 *
#ifdef __mac_os
	return strncmp(word1.word, word2.word, bound);
#endif
*/

d1000 2
a1001 2
		if(word1.word[i]!=word2.word[i])
			return((int)(word1.word[i]-word2.word[i]));
d1018 1
d1032 44
d1581 4
a1584 1
	if(file==NULL) return;
a1609 1
	free(words);
d1648 1
a1648 1
void save_model(char *filename, MODEL *model)
d1651 1
d1653 7
d1663 1
d2562 17
d2980 119
d3103 3
@


1.19
log
@Fixed a few little errors.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.18 1998/04/06 08:02:01 hutch Exp hutch $
a108 5
 *
 *		Bug reports
 *		-----------
 *
 *		SunOS requires drand48() to be declared.
d858 1
a858 1
		error("add_word", "Unable to reallocate the dictionary.");
d2615 1
d2618 2
a2620 1
	signal(SIGSEGV, die);
d2648 1
a2648 1
#if defined(__mac_os)
d2655 1
a2655 1
#if defined(__mac_os)
d2922 3
@


1.18
log
@Added debugging stuff, courtesy of Paul Baxter.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.17 1998/04/02 01:34:20 hutch Exp hutch $
d151 1
d177 1
d244 2
d255 1
d369 8
d443 11
d2733 106
d2845 10
a2854 4
	if(gSpeechExists && speech) {
		c2pstr(output);
		SpeakString((unsigned char *)output);
		p2cstr((StringPtr)output);
d2925 3
@


1.17
log
@Added the help function and fixed a few errors.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.16 1998/04/01 05:42:57 hutch Exp hutch $
d122 1
a122 1
	#include <malloc.h>
d130 2
a131 2
	#include <types.h>
	#include <Speech.h>
d133 1
a133 1
	#include <sys/types.h>
d135 3
a137 21

/*===========================================================================*/

#define P_THINK 40
#define D_KEY 100000
#define V_KEY 50000
#define D_THINK 500000
#define V_THINK 250000

#define MIN(a,b) ((a)<(b))?(a):(b)

#define COOKIE "MegaHALv8"

#define COMMAND_SIZE (sizeof(command)/sizeof(command[0]))

#define BYTE1 unsigned char
#define BYTE2 unsigned short
#define BYTE4 unsigned long

#ifdef __mac_os
	#define bool Boolean
a139 15
#ifdef AMIGA
	#undef toupper
	#define toupper(x) ToUpper(x)
	#undef tolower
	#define tolower(x) ToLower(x)
	#undef isalpha
	#define isalpha(x) IsAlpha(_AmigaLocale,x)
	#undef isalnum
	#define isalnum(x) IsAlNum(_AmigaLocale,x)
	#undef isdigit
	#define isdigit(x) IsDigit(_AmigaLocale,x)
	#undef isspace
	#define isspace(x) IsSpace(_AmigaLocale,x)
#endif

a141 56
#ifndef __mac_os
	#undef FALSE
	#undef TRUE
	typedef enum { FALSE, TRUE } bool;
#endif

typedef struct {
	BYTE1 length;
	char *word;
} STRING;

typedef struct {
	BYTE4 size;
	STRING *entry;
	BYTE2 *index;
} DICTIONARY;

typedef struct {
	BYTE2 size;
	STRING *from;
	STRING *to;
} SWAP;

typedef struct NODE {
	BYTE2 symbol;
	BYTE4 usage;
	BYTE2 count;
	BYTE2 branch;
	struct NODE **tree;
} TREE;

typedef struct {
	BYTE1 order;
	TREE *forward;
	TREE *backward;
	TREE **context;
	DICTIONARY *dictionary;
} MODEL;

typedef enum { UNKNOWN, QUIT, EXIT, SAVE, DELAY, HELP, SPEECH } COMMAND_WORDS;

typedef struct {
	STRING word;
	char *helpstring;
	COMMAND_WORDS command;
} COMMAND;

/*===========================================================================*/

#ifdef SUNOS
	extern double drand48(void);
	extern void srand48(long);
#endif

/*===========================================================================*/

d171 1
a171 1
	bool initialize_speech(void);
d203 1
a203 1
	char *strdup(const char *);
d217 1
a217 1
	void usleep(int);
d246 1
a246 1
	struct Locale *_AmigaLocale;
d250 1
a250 1
	Boolean gSpeechExists = false;
d982 4
d989 1
d2789 3
@


1.16
log
@Incorporated Mac code, including speech synthesis, and attempted
to tidy up the code for multi-platform support.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.15 1998/03/27 03:43:15 hutch Exp hutch $
d29 1
a29 1
 *		Program:		MegaHAL v8r4
d214 1
a214 1
typedef enum { UNKNOWN, QUIT, DELAY, HELP, SPEAK } COMMAND_WORDS;
d218 1
d224 7
d243 1
a243 1
bool error(char *, char *, ...);
d253 1
d260 1
a260 1
	Boolean InitSpeech(void);
d305 1
a305 1
#ifdef DOS
d326 6
a331 4
	{ { 1, "X" }, QUIT },
	{ { 1, "D" }, DELAY },
	{ { 1, "S" }, SPEAK },
	{ { 1, "H" }, HELP }
d404 1
a404 1
"|  #    #  ######   ####   #    #  #    #  #    #  ######    #     ###r4 |\n"
d428 3
d434 5
d444 1
a444 1
			case SPEAK:
d450 1
a450 1
				printf("MegaHAL help doesn't exist yet!\n");
d480 1
a480 2
	STRING word={ 2, "@@@@" };
	int tmp;
d638 1
a638 1
bool error(char *title, char *fmt, ...)
a1093 2
	register int i;

d2737 1
a2737 1
#ifdef DOS
d2757 1
a2757 1
	char *rval=(char *malloc(strlen(str)+1);
d2797 1
d2801 1
a2801 1
		SpeakString(output);
d2858 1
d2860 9
d2873 4
@


1.15
log
@Added AMIGA specific changes, thanks to Dag Agren.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.14 1998/02/20 06:40:13 hutch Exp hutch $
d29 1
a29 1
 *		Program:		MegaHAL v8
d55 59
d121 2
a122 2
#ifndef AMIGA
#include <malloc.h>
d129 6
a134 1
#include <sys/types.h>
d154 4
a157 1
//#define DAG
d159 12
a170 14
#undef toupper
#define toupper(x) ToUpper(x)
//#define toupper(x) ConvToUpper(_AmigaLocale,x)
#undef tolower
#define tolower(x) ToLower(x)
//#define tolower(x) ConvToLower(_AmigaLocale,x)
#undef isalpha
#define isalpha(x) IsAlpha(_AmigaLocale,x)
#undef isalnum
#define isalnum(x) IsAlNum(_AmigaLocale,x)
#undef isdigit
#define isdigit(x) IsDigit(_AmigaLocale,x)
#undef isspace
#define isspace(x) IsSpace(_AmigaLocale,x)
d175 5
a179 3
#undef FALSE
#undef TRUE
typedef enum { FALSE, TRUE } bool;
d214 1
a214 1
typedef enum { UNKNOWN, QUIT, SETUP, JUDGE, DELAY } COMMAND_WORDS;
d250 3
d269 1
d280 1
d282 3
d290 1
a290 1
void usleep(int);
d296 3
d306 1
d318 3
a320 1
	{ { 1, "D" }, DELAY }
d324 1
a324 1
struct Locale *_AmigaLocale;
d327 4
a351 1
	srand48(time(NULL));
d356 3
d393 1
a393 1
"|  #    #  ######   ####   #    #  #    #  #    #  ######    #     ###.4 |\n"
a396 1
"\n"
d420 14
d631 20
d730 1
d1053 4
d1141 6
a1146 1
	for(i=0; i<dictionary->size; ++i) save_word(file, dictionary->entry[i]);
d1162 6
a1167 1
	for(i=0; i<size; ++i) load_word(file, dictionary);
a1589 1
	int length=0;
d1591 1
a1591 3
#ifdef DAG
	int linenum=0;
#endif
d1598 3
a1600 3
#ifdef DAG
	printf("Training from file %s...\n\n",filename);
#endif
d1604 1
a1606 4
#ifdef DAG
		printf("\033[1FReading line %d...\n",++linenum);
#endif

d1616 2
d1619 1
a1623 4

#ifdef DAG
	printf("Training done.\n");
#endif
d1641 1
a1641 1
		error("show_dictionary", "Unable to open file");
d1670 1
a1670 1
		error("save_model", "Unable to open file `%s'", filename);
d1692 1
d1700 8
a1707 1
	for(i=0; i<node->branch; ++i) save_tree(file, node->tree[i]);
d1719 1
d1735 1
d1738 1
d1740 2
d1743 1
d1762 1
a1762 1
		error("load_model", "Unable to open file `%s'", filename);
a1765 4
#ifdef DAG
	printf("Loading model file %s...\n",filename);
#endif

d1768 1
a1768 1
		error("load_model", "File `%s' is not a MegaHAL brain", filename);
a1780 4
#ifdef DAG
	printf("Loading done.\n");
#endif

d1819 4
a1822 1
			words->entry=(STRING *)realloc(words->entry, (words->size+1)*sizeof(STRING));
d1846 4
a1849 1
		words->entry=(STRING *)realloc(words->entry, (words->size+1)*sizeof(STRING));
d2142 4
a2145 1
		replies->entry=(STRING *)realloc(replies->entry, (replies->size+1)*sizeof(STRING));
d2192 4
a2195 1
		replies->entry=(STRING *)realloc(replies->entry, (replies->size+1)*sizeof(STRING));
d2662 1
a2662 1
	if(sig!=0) error("ignore", "MegaHAL received signal %d", sig);
a2678 1
	fprintf(stderr, "Program died!  Please restart!\n");
d2692 13
d2706 1
d2721 1
d2729 1
d2731 111
d2846 3
@


1.14
log
@Tidied up transcript file format.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.13 1998/02/20 06:26:19 hutch Exp hutch $
d62 1
d64 1
d90 18
d242 4
d269 3
d342 4
d1457 3
d1466 4
d1474 4
d1492 4
d1624 4
d1642 5
d2574 3
@


1.13
log
@Fixed random number generator and Seed() function (thanks to Mark
Tarrabain), removed redundant code left over from the Loebner entry,
prettied things up a little and destroyed several causes of memory
leakage (although probably not all).
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.12 1998/02/04 02:55:11 hutch Exp hutch $
a574 3
	time_t clock;
	char timestamp[1024];
	struct tm *local;
a578 3
	clock=time(NULL);
	local=localtime(&clock);
	strftime(timestamp, 1024, "MHAL[%H:%M:%S]", local);
d583 1
a583 1
	width=60;
d587 1
a587 1
	if(bit==NULL) (void)status("%s%s\n", timestamp, formatted);
d589 1
a589 1
		(void)status("%s%s\n", timestamp, bit);
a639 4
	time_t clock;
	char timestamp[1024];
	char tmp[1024];
	struct tm *local;
d643 1
a643 6
	clock=time(NULL);
	local=localtime(&clock);
	strftime(tmp, 1024, "[%H:%M:%S]", local);
	sprintf(timestamp, "USER%s", tmp);

	width=60;
d647 1
a647 1
	if(bit==NULL) (void)status("%s%s\n", timestamp, formatted);
d649 1
a649 1
      (void)status("%s%s\n", timestamp, bit);
d2519 6
@


1.12
log
@Fixed up memory allocation error which caused SunOS versions to crash.
@
text
@d5 1
a5 1
 *  Copyright (C) 1997 Jason Hutchens
d25 1
a25 1
 *		$Id: megahal.c,v 1.11 1998/01/22 03:16:30 hutch Exp hutch $
a78 2
#define srandom(a) srand(a)
#define random() rand()
d90 2
a144 2
void change_judge(int);
void clear_screen(void);
d150 1
a150 1
COMMAND_WORDS execute_command(DICTIONARY *, bool);
a178 1
void prompt_judge(void);
a187 1
void setup(MODEL *model);
d200 1
d207 1
a207 2
int judge=0;
bool typing_delay=TRUE;
d219 1
a219 2
	{ { 1, "D" }, DELAY },
	{ { 1, "T" }, SETUP }
a239 16
	 *		Check that the type sizes are okay
	 */
	if(sizeof(BYTE1)!=1) {
		error("main", "BYTE1 size is %d", sizeof(BYTE1));
		return(0);
	}
	if(sizeof(BYTE2)!=2) {
		error("main", "BYTE2 size is %d", sizeof(BYTE2));
		return(0);
	}
	if(sizeof(BYTE4)!=4) {
		error("main", "BYTE4 size is %d", sizeof(BYTE4));
		return(0);
	}

	/*
d243 1
a243 1
	srandom(time(NULL));
d271 15
d289 4
a292 1
	setup(model);
d303 1
a303 1
		switch(execute_command(words, TRUE)) {
a306 8
			case SETUP:
				prompt_judge();
				make_greeting(words);
				break;
			case JUDGE:
				save_model("megahal.brn", model);
				make_greeting(words);
				break;
d326 1
a326 1
COMMAND_WORDS execute_command(DICTIONARY *words, bool allow_judge)
a355 10
			/*
			 *		Look for a judge number.
			 */
			if(allow_judge==TRUE) {
				tmp=atoi(words->entry[i+1].word);
				if((tmp>0)||((tmp==0)&&(words->entry[i+1].word[0]=='0'))) {
					change_judge(tmp);
					return(JUDGE);
				}
			}
a363 102
 *		Function:	Setup
 *
 *		Purpose:		Enter the configuration mode.
 */
void setup(MODEL *model)
{
	char buffer[1024];
	char *input=NULL;
	char *output=NULL;
	static DICTIONARY *words=NULL;
	char *filename;

	/*
	 *		Allocate a dictionary if necessary, make sure it is empty, clear
	 *		the screen, and set the judge number to zero.
	 */
	if(words==NULL) words=new_dictionary();
	words->size=0;

	/*
	 *		Get the filename for logging purposes.
	 */
	fprintf(stdout, "Filename: ");
	fflush(stdout);
	fgets(buffer, 1024, stdin);
	filename=strtok(buffer, " \n\t");
	if(initialize_status(filename)==FALSE) initialize_status("megahal.txt");

	/*
	 *		Display a greeting message to the judge.
	 */
	change_judge(0);
	make_greeting(words);
	output=generate_reply(model, words);
	write_output(output);

	/*
	 *		Loop until prompt_judge() is executed.
	 */
	while(judge==0) {
		input=read_input("+ ");
		write_input(input);
		upper(input);
		make_words(input, words);

		switch(execute_command(words, FALSE)) {
			case DELAY:
				typing_delay=(typing_delay==TRUE)?FALSE:TRUE;
				break;
			case SETUP:
				prompt_judge();
				make_greeting(words);
				break;
			default:
				break;
		}

		output=generate_reply(model, words);
		write_output(output);
	}
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Prompt_Judge
 *
 *		Purpose:		Read a judge number, and change the judge accordingly.
 */
void prompt_judge(void)
{
	char *input=NULL;
	static DICTIONARY *words=NULL;
	int num=judge;

	/*
	 *		Allocate a dictionary if necessary, make sure it is empty, clear
	 *		the screen, and set the judge number to zero.
	 */
	if(words==NULL) words=new_dictionary();
	words->size=0;
	clear_screen();

	/*
	 *		Loop until the judge number changes.
	 */
	while(num==judge) {
		input=read_input("? ");
		upper(input);
		make_words(input, words);
		switch(execute_command(words, TRUE)) {
			case QUIT:
				exithal();
			default:
				break;
		}
	}
}

/*---------------------------------------------------------------------------*/

/*
a375 17
 *		Function:	Clear_Screen
 *
 *		Purpose:		Clear an MS-DOS shell screen; necessary because
 *						system("CLS") doesn't work, nor does printf("\f")
 *						Bloody Microsoft!
 */
void clear_screen(void)
{
	register int i;

	for(i=0; i<25; ++i) fprintf(stdout, "\n");
	fflush(stdout);
}

/*---------------------------------------------------------------------------*/

/*
d558 2
a559 3
	fprintf(file, "(c)1998 Cambridge Center For Behavioral Studies all "
	"rights reserved\n");
	fprintf(file, "[MegaHALv8][Jason Hutchens]\n");
d584 1
a584 1
	strftime(timestamp, 1024, "PROGRAM[%H:%M:%S]", local);
d656 1
a656 1
	sprintf(timestamp, "JUDGE%02d%s", judge, tmp);
a671 13
 *		Function:	Change_Judge
 *
 *		Purpose:		Perform the necessary functions when changing a judge.
 */
void change_judge(int num)
{
	judge=num;
	(void)status("*** JUDGE%02d ***\n", judge);
}

/*---------------------------------------------------------------------------*/

/*
d937 8
a944 6
	if(dictionary->size==0) return;
	for(i=0; i<dictionary->size; ++i) free(dictionary->entry[i].word);
	free(dictionary->entry);
	dictionary->entry=NULL;
	free(dictionary->index);
	dictionary->index=NULL;
a945 2

	initialize_dictionary(dictionary);
a984 2
	initialize_dictionary(dictionary);

d1056 1
d1123 1
d1462 1
a1462 1
	free(words->entry);
d1624 1
a1624 1
	words->size=0;
d1646 1
d1744 5
a1748 2
	words->size=0;
	if(grt->size>2) (void)add_word(words, grt->entry[random()%(grt->size-2)+2]);
d1847 2
a1848 1
	else free_dictionary(keys);
d1866 1
a1866 1
	if(keys->size>2) for(i=0; i<words->size; ++i) {
d1938 1
a1938 1
	replies->size=0;
d2128 1
a2128 1
		output=(char *)malloc(output, sizeof(char));
d2192 2
a2193 2
	i=random()%(node->branch);
	count=random()%(node->usage);
d2248 3
d2252 1
a2252 1
	else symbol=random()%(model->context[0]->branch);
d2254 2
a2255 2
	if(keys->size>2) {
		do { i=random()%(keys->size); } while(i<2);
d2266 1
a2266 1
			if(i==keys->size) i=2;
d2440 1
a2440 1
	usleep((D_THINK+random()%V_THINK-random()%V_THINK)/2);
d2456 1
a2456 1
	usleep(D_KEY+random()%V_KEY-random()%V_KEY);
d2463 2
a2464 2
	if((!isalnum(c))&&((random()%100)<P_THINK))
		usleep(D_THINK+random()%V_THINK-random()%V_THINK);
d2501 12
d2534 3
@


1.11
log
@Fixed several memory leaks, and the frustrating bug in the
Write_Input routine.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.10 1998/01/19 06:44:36 hutch Exp hutch $
d2276 8
d2454 16
d2668 4
d2693 1
a2693 1
 *		the almost finished version.
d2696 1
a2696 1
 *		Now Loebner complient (tm)
d2702 1
a2702 1
 *		Initial revision
d2705 1
a2705 1
 *		Added load and save functions, and tidied up some code/
d2725 1
a2725 4
 *		Initial revision
 *
 *		Revision 1.1  1997/07/15 01:54:21  hutch
 *		Initial revision
@


1.10
log
@Fixed MegaHAL to compile under Linux with a small patch credited
to Joey Hess (joey@@kitenet.net).  MegaHAL may now be included as
part of the Debian Linux distribution.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.9 1998/01/19 06:37:32 hutch Exp hutch $
a197 1
char *update_output(char *, char *, bool);
a522 1
	char *tmp;
d581 2
a582 2
		tmp=(char *)realloc((char *)input,sizeof(char)*(length+1));
		if(tmp==NULL) {
d584 1
a584 3
			return(input);
		} else {
			input=tmp;
d805 1
a805 1
      (void)status("%s%s\n", timestamp, formatted);
a1526 37
 *		Function:	Update_Output
 *
 *		Purpose:		Add a new word either at the beginning or end of the
 *						current output string.
 */
char *update_output(char *output, char *word, bool prepend)
{
	register int i;
	int length;
	int lout;
	int lword;

	lout=strlen(output);
	lword=strlen(word);

	length=lout+lword+2;
	output=(char *)realloc((char *)output, sizeof(char)*length);
	if(output==NULL) {
		error("update_output", "Unable to re-allocate output");
		return("ERROR");
	}

	if(prepend==FALSE) {
		strcat(output, word);
	} else {
		for(i=lout; i>=0; --i)
			output[lword+i]=output[i];
		for(i=0; i<lword; ++i)
			output[i]=word[i];
	}

	return(output);
}

/*---------------------------------------------------------------------------*/

/*
a1772 1
	STRING *tmp;
d1799 2
a1800 2
			tmp=(STRING *)realloc(words->entry, (words->size+1)*sizeof(STRING));
			if(tmp==NULL) {
d1803 1
a1803 2
			} else
				words->entry=tmp;
d1822 2
a1823 2
		tmp=(STRING *)realloc(words->entry, (words->size+1)*sizeof(STRING));
		if(tmp==NULL) {
d1826 1
a1826 2
		} else
			words->entry=tmp;
d1917 1
a1917 1
	char *output_none;
d1929 5
a1933 2
	output_none=malloc(40);
	strcpy(output_none, "I don't know enough to answer you yet!");
d2081 1
a2081 2
	DICTIONARY *replies=NULL;
	STRING *tmp;
d2111 2
a2112 2
		tmp=(STRING *)realloc(replies->entry, (replies->size+1)*sizeof(STRING));
		if(tmp==NULL) {
d2114 2
a2115 3
			return(replies);
		} else
			replies->entry=tmp;
d2158 2
a2159 2
		tmp=(STRING *)realloc(replies->entry, (replies->size+1)*sizeof(STRING));
		if(tmp==NULL) {
d2161 2
a2162 3
			return(replies);
		} else
			replies->entry=tmp;
d2268 1
a2268 1
	char *output=NULL;
a2270 1
	char *tmp;
d2272 3
d2277 2
a2278 2
		char *output_none=malloc(40);
		strcpy(output_none, "I am utterly speechless!");
d2285 2
a2286 3
	tmp=(char *)realloc(output, sizeof(char)*length);
	if(tmp==NULL) {
		char *output_none=malloc(40);
d2288 2
a2289 1
		strcpy(output_none, "I forgot what I was going to say!");
a2290 2
	} else {
		output=tmp;
d2644 5
@


1.9
log
@Fixed a minor bug with end-of-sentence punctuation.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.8 1997/12/24 03:17:01 hutch Exp hutch $
d1961 1
d1973 3
a1975 1
	output="I don't know enough to answer you yet!";
d2318 5
a2322 1
	if(words->size==0) return("I am utterly speechless!");
d2329 1
d2331 2
a2332 1
		return("I forget what I was going to say!");
d2688 3
@


1.8
log
@More bug fixes, and hopefully the final contest version!
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.7 1997/12/22 13:18:09 hutch Exp hutch $
d371 1
a371 1
			if(allow_judge==TRUE) {
d376 1
a376 1
				}
d1876 1
a1876 1
	else if(strchr("!.?", words->entry[words->size-1].word[0])==NULL) {
d2679 3
@


1.7
log
@A few more bug fixes, and non-repeating implemented.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.6 1997/12/22 04:27:04 hutch Exp hutch $
a68 1
#include <sys/time.h>
d152 1
a152 1
COMMAND_WORDS execute_command(DICTIONARY *);
d307 1
a307 1
		switch(execute_command(words)) {
d338 1
a338 1
COMMAND_WORDS execute_command(DICTIONARY *words)
d371 6
a376 4
			tmp=atoi(words->entry[i+1].word);
			if((tmp>0)||((tmp==0)&&(words->entry[i+1].word[0]=='0'))) {
				change_judge(tmp);
				return(JUDGE);
d431 1
a431 1
		switch(execute_command(words)) {
d476 1
a476 1
		switch(execute_command(words)) {
a1632 1
	int c;
d2294 2
a2295 2
	if(num>=10) entropy/=(float)sqrt(num-1);
	if(num>=20) entropy/=(float)num;
d2679 3
@


1.6
log
@A few minor bug fixes.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.5 1997/12/15 04:35:59 hutch Exp hutch $
d128 1
a128 1
typedef enum { UNKNOWN, QUIT, SETUP, JUDGE } COMMAND_WORDS;
d150 1
a158 2
void free_model(MODEL *);
bool free_tree(TREE *);
d210 1
a210 1
int order=4;
d213 1
d225 2
a226 3
	{ { 1, "T" }, SETUP },
	{ { 1, "x" }, QUIT },
	{ { 1, "t" }, SETUP }
d305 3
d408 1
d429 1
d431 3
d510 1
d597 3
d705 1
a1290 56
 *		Function:	Free_Model
 *
 *		Purpose:		Release the memory of the ngram model.
 */
void free_model(MODEL *model)
{
	free_dictionary(model->dictionary);
	free(model->dictionary);
	free(model->context);
	model->context=NULL;
	free_tree(model->forward);
	free_tree(model->backward);
	model->forward=NULL;
	model->backward=NULL;
	model->order=0;
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Free_Tree
 *
 *		Purpose:		Recursively free the memory occupied by the ngram tree.
 */
bool free_tree(TREE *tree)
{
	register int i;

	/*
	 *		Check the input conditions
	 */
	if(tree==NULL) {
		error("free_tree", "The tree is NULL.");
		goto fail;
	}

	/*
	 *		Recursively call this function on all the subtrees of the current
	 *		node.
	 */
	for(i=0; i<tree->branch; ++i) free_tree(tree->tree[i]);

	/*
	 *		Finally, free up the memory occupied by the current node.
	 */
	free(tree);

	return(TRUE);

fail:
	return(FALSE);
}

/*---------------------------------------------------------------------------*/

/*
d1633 1
a1633 1
	char *buffer=NULL;
a1635 1
	bool stop;
a1641 6
	buffer=(char *)malloc(sizeof(char));
	if(buffer==NULL) {
		error("train", "Unable to allocate buffer");
		return;
	}

a1643 1
	stop=FALSE;
d1646 2
a1647 1
		c=getc(file);
d1649 1
a1649 5
		buffer=(char *)realloc((char *)buffer,sizeof(char)*(length+2));
		if(buffer==NULL) {
			error("train", "Unable to re-allocate buffer");
			return;
		}
d1651 3
a1653 1
		if((char)c=='\n') stop=TRUE;
a1654 16
		if(((stop==TRUE)&&(isalpha(c)))||(c==EOF)) {
			buffer[length]='\0';
			length=0;
			upper(buffer);
			if(buffer[0]!='#') {
				make_words(buffer, words);
				learn(model, words);
			}
			stop=FALSE;
			if(c==EOF) break;
		}

		if((char)c!='\n') {
			buffer[length]=(char)c;
			++length;
		}
a1656 1
	free(buffer);
a1681 1
		fprintf(file, "(");
d1684 1
a1684 1
		fprintf(file, ")\n");
d1942 1
a1942 1
	if(grt->size>0) (void)add_word(words, grt->entry[random()%(grt->size)]);
d1967 6
a1973 1
	keywords=make_keywords(model, words);
d1975 1
a1975 1
	output=make_output(replywords);
d1981 1
a1981 1
	max_surprise=(float)0.0;
d1988 1
a1988 1
		if(surprise>max_surprise) {
a1994 6
	 *		Display some statistics about the process
	 */
	fprintf(stderr, "MegaHAL generated %d replies; the best scored %f bits.\n",
		count, max_surprise);

	/*
d2003 18
d2294 2
a2295 1
	if(num>=8) entropy/=(float)sqrt(num-1);
d2586 9
a2594 1
	 *		Display the entire string, one character at a time.
d2596 3
a2598 1
	for(i=0; i<(int)strlen(string); ++i) typein(string[i]);
d2679 3
@


1.5
log
@Final Loebner version!
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.4 1997/12/11 05:45:29 hutch Exp hutch $
d69 1
a72 1
#define BS 8
a75 4
#define D_BS 80000
#define V_BS 30000
#define D_PAUSE 200000
#define V_PAUSE 100000
a149 1
bool dissimilar(DICTIONARY *, DICTIONARY *);
d212 1
a212 2
int timeout=4;
int debug=0;
a213 3
bool update=TRUE;
bool fullstop=FALSE;
bool uppercase=TRUE;
d287 2
a288 1
	 *		Read a dictionary containing banned keywords.
d539 1
d562 1
a765 1
	if(uppercase==FALSE) return;
d1706 1
a1706 2
		if((fullstop==TRUE)&&(strchr("!?.", (char)c)!=NULL)) stop=TRUE;
		else if ((char)c=='\n') stop=TRUE;
d1708 1
a1708 1
		if(((stop==TRUE)&&(isalpha(c)||!fullstop))||(c==EOF)) {
d1720 1
a1720 6
		if((char)c=='\n') {
			if(fullstop) {
				buffer[length]=' ';
				++length;
			}
		} else {
a1985 2
		(position<(int)strlen(string)-2)&&
		(string[position+1]=='\'')&&
a1986 6
		(isalpha(string[position+2])!=0)
	)
		return(FALSE);

	if(
		(isalpha(string[position])!=0)&&
d2054 1
a2054 1
		if((surprise>max_surprise)&&(dissimilar(words, replywords)==TRUE)) {
d2058 1
a2058 1
	} while(time(NULL)-basetime<timeout);
a2062 1
	/*
a2064 1
	*/
a2074 19
 *		Function:	Dissilimar
 *
 *		Purpose:		Compare two dictionaries, and return whether they're the
 *						same or not.
 */
bool dissimilar(DICTIONARY *dict1, DICTIONARY *dict2)
{
	register int i;

	if(dict1->size!=dict2->size) return(TRUE);
	for(i=0; i<dict1->size; ++i)
		if(wordcmp(dict1->entry[i], dict2->entry[i])!=0) return(TRUE);
		
	return(FALSE);
}

/*---------------------------------------------------------------------------*/

/*
a2091 1

d2348 1
a2348 1
	if(num>0) entropy/=(float)num;
a2603 1
	list->size=0;
d2616 1
a2616 1
		if(strlen(string)>0) {
d2658 1
d2663 1
a2663 1
	if((!isalnum(c))&&((random()%100)<P_THINK)) {
a2664 1
	}
d2707 1
a2707 1
 *						no-one was noticed.  Modified from a real Microsoft
d2722 3
@


1.4
log
@the almost finished version.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.3 1997/12/10 09:08:09 hutch Exp hutch $
a67 1
#include <sys/time.h>
a71 6
#define P_ERROR 4
#define P_SPOT 30
#define P_DOUBLE 20
#define P_MISS 40
#define P_UPPER 60
#define P_THINK 30
d73 6
a78 5
#define D_KEY 150000
#define V_KEY 100000
#define D_BS 120000
#define V_BS 50000
#define D_PAUSE 250000
d80 2
a81 2
#define D_THINK 600000
#define V_THINK 300000
d84 2
d151 4
d202 1
d207 1
d209 1
a211 4
void delay(char *);
void typein(char);
char mangle(char);
bool word_exists(DICTIONARY *, STRING);
d215 1
a215 1
int width=60;
a229 2
char *keyboard="!qwertyuiop[!asdfghjkl;!zxcvbnm,";
bool kapital;
a276 1
	/*
a277 1
	*/
d312 1
a331 1
		learn(model, words);
d467 1
a467 1
	fprintf(stdout, "");
d500 16
d724 1
d727 2
d731 1
d750 1
a750 1
	for(i=0; i<strlen(string); ++i) {
d773 1
a773 1
	for(i=0; i<strlen(string); ++i) string[i]=(char)toupper((int)string[i]);
d797 1
d801 1
d851 1
a851 1
   for(i=0; i<strlen(output); ++i) {
d864 1
a864 1
	if(formatted[j-1]!='\n') {
a1241 1
succeed:
a1257 1
	register int i;
a1276 1
succeed:
a1332 1
succeed:
a1348 1
	TREE *node;
d1356 1
a1356 1
			model->context[i]=add_symbol(model->context[i-1], symbol);
a1425 1
succeed:
a1426 3

fail:
	return(NULL);
a1457 1
succeed:
a1458 3

fail:
	return(NULL);
d1485 1
a1485 1
		goto fail;
a1499 6

succeed:
	return;

fail:
	return;
a1561 4

fail:
	*found_symbol=FALSE;
	return(-1);
a1899 1
	register int i;
d1936 1
a1936 1
			if(offset==strlen(input)) break;
d1980 1
a1980 1
	if(position==strlen(string))
d1984 1
a1984 1
		((string[position]=='\'')||(string[position]=='-'))&&
d1992 1
a1992 1
		((string[position-1]=='\'')||(string[position-1]=='-'))&&
d1999 2
a2000 2
		(position<strlen(string)-2)&&
		((string[position+1]=='\'')||(string[position+1]=='-'))&&
a2032 2
	register int i;

d2047 1
d2059 1
d2061 2
d2068 1
a2068 1
	max_surprise=-1.0;
d2075 1
a2075 1
		if(surprise>max_surprise) {
d2084 2
a2085 1
	fprintf(stdout, "MegaHAL generated %d replies; the best scored %f bits.\n",
d2087 1
d2098 19
a2125 1
	BYTE2 *tmp;
a2128 1
	STRING *word;
d2250 1
a2250 1
			return;
d2298 1
a2298 1
			return;
d2338 1
a2338 1
	float entropy=0.0;
d2342 1
a2342 1
	if(words->size<=0) return(0.0);
d2349 1
a2349 1
			probability=0.0;
d2361 1
a2361 1
			if(count>0.0) entropy-=log(probability/(float)count);
d2373 1
a2373 1
			probability=0.0;
d2385 1
a2385 1
			if(count>0.0) entropy-=log(probability/(float)count);
a2605 1
	int c;
d2681 1
a2681 7
	register int j;
	register int b;
	char c;
	bool correct;

	fprintf(stdout, string);
	return;
a2682 9
	 *		Initialize variables.
	 */
	j=-1;
	b=-1;
	i=0;
	kapital=FALSE;
	correct=FALSE;

	/*
d2685 1
a2685 113
	while(i<(int)strlen(string)) {

		/*
		 *		Get the current character from the string.
		 */
		c=string[i];

		/*
		 *		If the character is alpabetic, and we haven't already corrected
		 *		a typing mistake, and we randomly decide that a mistake should
		 *		occur, then make a typing mistake.
		 */
		if(isalpha(c)&&((random()%100)<P_ERROR)&&(correct==FALSE)) {
			/*
			 *		Make a typing mistake where the CAPS-LOCK key is pressed,
			 *		so that everything goes into uppercase.
			 */
			if((c>=65)&&(c<=90)&&((random()%100)<P_UPPER)) {
				kapital=TRUE;
				typein(c);
				if(j<0) {
					j=i+1;
					b=0;
				} else {
					++b;
				}
			/*
			 *		Make a typing mistake whereby the current character is
			 *		typed twice instead of once.
			 */
			} else if((random()%100)<P_DOUBLE) {
				typein(c);
				typein(c);
				if(j<0) {
					j=i+1;
					b=1;
				} else {
					b+=2;
				}
			/*
			 *		Make a typing mistake where the current character is
			 *		ommitted entirely.
			 */
			} else if((random()%100)<P_MISS) {
				if(j<0) {
					j=i;
					b=0;
				}
			/*
			 *		Make a typing mistake by replacing the current character
			 *		with another character which is nearby on the keyboard.
			 */
			} else {
				typein(mangle(c));
				if(j<0) {
					j=i;
					b=1;
				} else {
					++b;
				}
			}
		} else {
			/*
			 *		No mistakes occurred, so type the character exactly.
			 */
			typein(c);
			if(j>=0) {
				++b;
			}
		}

		/*
		 *		Re-initialize some variables if a newline is encountered.
		 */
		if(c=='\n') {
			j=-1;
			b=-1;
		}

		/*
		 *		Go to the next character in the string.
		 */
		++i;

		/*
		 *		If a mistake has been made, and we randomly decide to correct
		 *		it, then correct it!
		 */
		if(((random()%100)<P_SPOT)&&(j>=0)&&(b>1)) {
			/*
			 *		Once we have corrected a mistake, we guarantee that no more
			 *		mistakes will be made in the current string.
			 */
			correct=TRUE;
			/*
			 *		It's only worth correcting a mistake if it occurred less than
			 *		eight characters ago.  Simply backspace the appropriate
			 *		amount, and set the index into the string to the appropriate
			 *		position.
			 */
			if(b<8) {
				while(b>0) {
					--b;
					printf("%c ", BS);
					typein(BS);
				}
				i=j;
			}
			j=-1;
			b=-1;
			kapital=FALSE;
		}
	}
a2696 2
	static bool flag=FALSE;

d2698 1
a2698 1
	 *		Standard keyboard delay, or backspace delay
d2700 3
a2702 6
	if(flag==FALSE) {
		usleep(D_KEY+random()%V_KEY-random()%V_KEY);
	} else {
		usleep(D_BS+random()%V_BS-random()%V_BS);
	}

a2703 30
	 *		Got to source of error, so think before fixing it
	 */
	if((flag==TRUE)&&(c!=BS)) {
		usleep(D_PAUSE+random()%V_PAUSE-random()%V_PAUSE);
		flag=FALSE;
	}

	/*
	 *		Starting to backspace, so pause before first backspace
	 */
	if((c==BS)&&(flag==FALSE)) {
		usleep(D_PAUSE+random()%V_PAUSE-random()%V_PAUSE);
	}

	/*
	 *		Display the character.
	 */
	if(kapital==TRUE) fprintf(stdout, "%c", toupper(c));
	else fprintf(stdout, "%c", c);
	fflush(stdout);

	/*
	 *		Pause after first backspace
	 */
	if((c==BS)&&(flag==FALSE)) {
		flag=TRUE;
		usleep(D_KEY+random()%V_KEY-random()%V_KEY);
	}

	/*
a2705 1
	if(c==BS) return;
a2708 1

d2714 1
a2714 1
 *		Function:	Mangle
d2716 1
a2716 1
 *		Purpose:		Change a character to another to emulate typing errors.
d2718 1
a2718 1
char mangle(char c)
d2720 1
a2720 1
	register int i;
d2722 5
a2726 1
	if(isalnum(c)==0) return(c);
d2728 1
a2728 1
	for(i=0; i<(int)strlen(keyboard); ++i) if(keyboard[i]==c) break;
d2730 10
a2739 4
	if(((random()%100)<50)||(keyboard[i-1]=='!')) ++i;
	else --i;

	return(keyboard[i]);
d2745 1
a2745 1
 *		Function:	Ignore
d2747 6
a2752 1
 *		Purpose:		Log the occurrence of a signal, but ignore it.
d2754 1
a2754 1
void ignore(int sig)
d2756 1
a2756 1
	if(sig!=0) error("ignore", "MegaHAL received signal %d", sig);
d2758 2
a2759 8
	signal(SIGINT, ignore);
	signal(SIGQUIT, ignore);
	signal(SIGILL, ignore);
	signal(SIGFPE, ignore);
	signal(SIGSEGV, ignore);
	signal(SIGSYS, ignore);
	signal(SIGTSTP, ignore);
	signal(SIGBUS, ignore);
d2766 3
@


1.3
log
@Now Loebner complient (tm)
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.2 1997/12/08 06:22:32 hutch Exp hutch $
d64 1
d77 1
a78 1
#define P_UPPER 60
d80 1
a80 1
#define D_KEY 200000
d84 1
a84 1
#define D_PAUSE 500000
d86 2
a87 2
#define D_THINK 800000
#define V_THINK 400000
a89 1
#define MAX(a,b) ((a)>(b))?(a):(b)
a90 12
#if ARCH==IRIX || ARCH==IRIX64
#define log2(x) (log(x)/log(2))
#endif

#ifdef TRUE
#undef TRUE
#endif

#ifdef FALSE
#undef FALSE
#endif

d152 1
a152 1
void bug(int, char *, ...);
d167 1
a182 1
void message(char *, ...);
a190 1
bool rule(FILE *, char);
a199 2
void show_word(STRING);
void show_words(DICTIONARY *);
d217 2
a218 2
int order=6;
int timeout=2;
a223 1
bool loebner=FALSE;
a279 1

d281 2
a282 8
	 *		Display a welcoming message.
	 */
	message(
		"+------------------------------------------+\n"
		"| MegaHAL Conversation Simulator Version 8 |\n"
		"|   Copyright (C) 1997 Jason L. Hutchens   |\n"
		"+------------------------------------------+\n"
	);
a611 40
 *		Function:	Message
 *
 *		Purpose:		Display a message to stdout if the program is *not* in
 *						Loebner mode.
 */
void message(char *fmt, ...)
{
	va_list argp;

	if(loebner) return;

	va_start(argp, fmt);
	vfprintf(stdout, fmt, argp);
	va_end(argp);
	fflush(stdout);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Bug
 *
 *		Purpose:		Display a debugging message, if the level is less than
 *						or equal to the debug level.
 */
void bug(int level, char *fmt, ...)
{
	va_list argp;

	if(debug<level) return;

	va_start(argp, fmt);
	vfprintf(stdout, fmt, argp);
	va_end(argp);
	fflush(stdout);
}

/*---------------------------------------------------------------------------*/

/*
d681 3
a683 4
	if(loebner) {
		clock=time(NULL);
		local=localtime(&clock);
		strftime(timestamp, 1024, "Start at: [%Y/%m/%d %H:%M:%S]\n", local);
d685 4
a688 8
		fprintf(file, "(c)1998 Cambridge Center For Behavioral Studies all "
		"rights reserved\n");
		fprintf(file, "[MegaHALv8][Jason Hutchens]\n");
		fprintf(file, timestamp);
	} else {
		clock=time(NULL);
		local=localtime(&clock);
		strftime(timestamp, 1024, "Date: %A %d %B, %Y\nTime: %T\n", local);
a689 7
		rule(file, '-');
		fprintf(file, "MegaHAL version 8\n");
		fprintf(file, "Copyright (C) 1997 Jason Hutchens\n");
		fprintf(file, timestamp);
		rule(file, '-');
	}

a695 16
 *		Function:	Rule
 *
 *		Purpose:		Display a horizontal rule, used for sectioning output.
 */
bool rule(FILE *file, char style)
{
	register int i;

	for(i=0; i<width+6; ++i) fprintf(file, "%c", style);
	fprintf(file, "\n");
	return(TRUE);
}

/*---------------------------------------------------------------------------*/

/*
d709 3
a711 7
	if(loebner) {
		clock=time(NULL);
		local=localtime(&clock);
		strftime(timestamp, 1024, "PROGRAM[%H:%M:%S]", local);
	} else {
		sprintf(timestamp, "MegaHAL: ");
	}
a719 1
		if(!loebner) sprintf(timestamp, "         ");
d777 4
a780 8
	if(loebner) {
		clock=time(NULL);
		local=localtime(&clock);
		strftime(tmp, 1024, "[%H:%M:%S]", local);
		sprintf(timestamp, "JUDGE%02d%s", judge, tmp);
	} else {
		sprintf(timestamp, "User:    ");
	}
a787 1
		if(!loebner) sprintf(timestamp, "         ");
a1127 33
 *		Function:	Show_Words
 *
 *		Purpose:		Show the contents of a dictionary.
 */
void show_words(DICTIONARY *words)
{
	register int i;

	for(i=0; i<words->size; ++i)
		show_word(words->entry[i]);
	message("\n");
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Show_Word
 *
 *		Purpose:		Show a particular word.
 */
void show_word(STRING word)
{
	register int i;

	message("(");
	for(i=0; i<word.length; ++i)
		message("%c", word.word[i]);
	message(")");
}

/*---------------------------------------------------------------------------*/

/*
a1905 2
	char c;
	char p;
a1918 6
	 *		Initialize the two character variables
	 */
	c=input[offset];
	p=c;

	/*
d1928 1
a1928 6
		if(
			((isalpha(p)==0)&&(isalpha(c)!=0)) ||
			((isalpha(p)!=0)&&(isalpha(c)==0)) ||
			(isdigit(p)!=isdigit(c)!=0) ||
			(offset==strlen(input))
		) {
a1948 6

		/*
		 *		Set the previous and next characters accordingly.
		 */
		p=c;
		c=input[offset];
d1977 56
d2043 1
a2043 1
	for(i=0; i<grt->size; ++i) (void)add_word(words, grt->entry[i]);
a2067 4
	if(keywords->size>2) {
		message("%d keywords found:-\n", keywords->size-2);
		show_words(keywords);
	}
d2089 1
a2089 1
	message("MegaHAL generated %d replies; the best scored %f bits.\n",
d2328 1
d2347 1
a2347 1
			if(count>0.0) entropy-=log2(probability/(float)count);
d2371 1
a2371 1
			if(count>0.0) entropy-=log2(probability/(float)count);
d2377 1
a2377 1
	if(num>0) entropy/=(float)sqrt((float)num);
d2634 1
d2673 2
a2675 8
	 *		If we're not in Loebner mode, then print the string with no delay.
	 */
	if(loebner==FALSE) {
		fprintf(stdout, string);
		return;
	}

	/*
d2883 21
d2908 3
@


1.2
log
@Tidied up.
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.1 1997/12/05 07:11:44 hutch Exp hutch $
d72 16
a154 5
COMMAND command[] = {
	{ { 1, "X" }, QUIT },
	{ { 1, "T" }, SETUP }
};

d163 1
a163 1
int babble(MODEL *, DICTIONARY *);
d165 1
d170 1
d190 1
d200 2
a201 1
char *read_input(void);
d210 3
a212 1
void setup(void);
d218 1
a218 1
void update_model(MODEL *, int, int);
d224 4
d232 1
a232 1
int order=4;
d243 1
d247 3
a249 2
float entropy;
int counter;
d251 7
a294 1
	initialize_status("megahal.txt");
d328 1
d334 1
d336 1
a336 1
		input=read_input();
d343 2
a344 2
				message("You have chosen to quit.\n");
				goto exit;
d346 2
a347 1
				setup();
d349 4
a361 1
exit:
d423 1
a423 1
void setup(void)
d425 3
a427 1
	char input[1024];
d429 58
d489 4
d495 1
a495 1
	fprintf(stderr, "");
d497 3
d501 1
a501 2
		fprintf(stderr, "? ");
		fgets(input, 1024, stdin);
d504 6
a509 1
		execute_command(words);
d516 12
d532 1
a532 1
char *read_input(void)
d558 1
a558 1
	fprintf(stdout, "> ");
d580 1
a580 1
			fprintf(stdout, "> ");
d703 1
a703 1
	if(filename==NULL) return(TRUE);
d799 1
d809 1
a809 1
	fprintf(stdout, "%s\n", formatted);
a811 1
	if(bit==NULL) (void)status("%s%s\n", timestamp, formatted);
d822 23
a884 1
   if(bit==NULL) (void)status("%s%s\n", timestamp, formatted);
d927 1
a927 1
   formatted=(char *)realloc((char *)formatted, sizeof(char)*strlen(output));
d948 4
d1467 1
a1467 1
void update_model(MODEL *model, int symbol, int pos)
d1476 1
a1476 3
	for(i=(model->order+1); i>0; --i) {
		if(pos==0) break;
		--pos;
a1478 1
	}
d1784 1
a1784 1
		update_model(model, symbol, words->size-i+1);
d1789 1
a1789 1
	update_model(model, 1, 1);
d1803 1
a1803 1
		update_model(model, symbol, i+2);
d1808 1
a1808 1
	update_model(model, 1, 1);
d1888 29
d1925 1
d2070 6
a2075 2
		if(((isalpha(p)!=isalpha(c))||(isdigit(p)!=isdigit(c)))||(offset==strlen(input))) {

d2108 13
a2120 2
	/*
	if(strchr("!.?", words->entry[words->size-1].word[0])==NULL) {
a2123 1
	*/
d2130 15
d2237 1
a2237 1
	if(keys->size>0) for(i=0; i<words->size; ++i) {
d2307 1
a2310 2
	entropy=0.0;
	counter=0;
d2317 1
d2326 2
a2327 1
		symbol=babble(model, keys);
d2329 1
d2376 1
a2376 1
		symbol=babble(model, keys);
d2421 7
d2429 50
d2497 1
a2497 1
	if(words->size==0) return("I HAVE NOTHING TO SAY!");
d2505 1
a2505 1
		return("I CAN'T REMEMBER WHAT I WAS GOING TO SAY!");
d2531 1
a2531 1
int babble(MODEL *model, DICTIONARY *keys)
a2533 1
	TREE *child;
d2554 2
a2555 1
		 *		If the symbol occurs as a keyword, then use it.
d2559 8
a2566 11
		if(find_word(keys, model->dictionary->entry[symbol])!=0) {
			child=find_symbol(model->context[0], symbol);
			if(child!=NULL) {
				entropy+=-log2((float)(child->count)/
					(float)(model->context[0]->usage));
				++counter;
				entropy+=-log2((float)(node->tree[i]->count)/
					(float)(node->usage));
				++counter;
				break;
			}
d2578 54
d2757 231
d2992 3
@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
 *		$Id: megahal.c,v 1.7 1997/12/04 07:07:13 hutch Exp hutch $
d64 1
a68 1
#include <sys/resource.h>
d91 4
d100 1
a100 1
	unsigned char length;
d105 1
a105 1
	unsigned long size;
d107 1
a107 1
	unsigned short *index;
d111 1
a111 1
	unsigned int size;
d117 4
a120 4
	unsigned short symbol;
	unsigned long usage;
	unsigned short count;
	unsigned short branch;
d125 1
a125 1
	unsigned char order;
d132 1
a132 1
typedef enum { UNKNOWN, QUIT, SETUP, HELP, SAVE, USAGE, CASE, DEBUG, METHOD, LEARN, JUDGE } COMMAND_WORDS;
d139 1
a139 1
static COMMAND command[] = {
d141 1
a141 9
	{ { 1, "T" }, SETUP },
	{ { 4, "QUIT" }, QUIT },
	{ { 4, "HELP" }, HELP },
	{ { 4, "SAVE" }, SAVE },
	{ { 6, "STATUS" }, USAGE },
	{ { 4, "CASE" }, CASE },
	{ { 5, "DEBUG" }, DEBUG },
	{ { 6, "METHOD" }, METHOD },
	{ { 5, "LEARN" }, LEARN }
d146 22
a167 5
static COMMAND_WORDS execute_command(DICTIONARY *);
static void help(void);
static void set_method(void);
static void setup(void);
char *read_input(void);
d169 1
d171 9
a179 6
bool error(char *, char *, ...);
bool status(char *, ...);
void write_output(char *);
void write_input(char *);
char *format_output(char *);
void upper(char *);
a180 8
void bug(int, char *, ...);
static bool print_header(FILE *);
static bool rule(FILE *, char);
static char *show_size(int);
unsigned int add_word(DICTIONARY *, STRING);
void free_dictionary(DICTIONARY *);
unsigned short find_word(DICTIONARY *, STRING);
char *symbol_to_string(DICTIONARY *, int, bool);
d182 7
a188 4
int wordcmp(STRING, STRING);
void show_dictionary(DICTIONARY *);
void show_words(DICTIONARY *);
void show_word(STRING);
a189 9
void load_dictionary(FILE *, DICTIONARY *);
static char *convert_character(char, bool);
static int search_dictionary(DICTIONARY *, STRING, bool *);
static void initialize_dictionary(DICTIONARY *);
static void save_word(FILE *, STRING);
static void load_word(FILE *, DICTIONARY *);
MODEL *new_model(int);
void free_model(MODEL *);
void learn(MODEL *, DICTIONARY *);
d191 16
a206 28
void load_model(char *, MODEL *);
void make_words(char *, DICTIONARY *);
char *generate_reply(MODEL *, DICTIONARY *);
DICTIONARY *initialize_list(char *);
SWAP *initialize_swap(char *);
static void update_model(MODEL *, int, int);
static TREE *find_symbol(TREE *, int);
static void initialize_context(MODEL *);
static void update_context(MODEL *, int);
static bool free_tree(TREE *);
static TREE *new_node(void);
static TREE *add_symbol(TREE *, unsigned short);
static void add_node(TREE *, TREE *, int);
static TREE *find_symbol_add(TREE *, int);
static int search_node(TREE *, int, bool *);
static int babble(MODEL *, DICTIONARY *);
static void show_tree(MODEL *, TREE *, TREE *, char *);
static char *update_output(char *, char *, bool);
static float evaluate_reply(MODEL *, DICTIONARY *, DICTIONARY *);
static DICTIONARY *reply(MODEL *, DICTIONARY *);
static DICTIONARY *make_keywords(MODEL *, DICTIONARY *);
static char *make_output(DICTIONARY *);
static SWAP *new_swap(void);
static void add_swap(SWAP *, char *, char *);
static void add_key(MODEL *, DICTIONARY *, STRING);
static void add_aux(MODEL *, DICTIONARY *, STRING);
static void save_tree(FILE *, TREE *);
static void load_tree(FILE *, TREE *);
d212 3
a214 8
char *brainfilename="megahal.brn";
char *banfilename="megahal.ban";
char *auxfilename="megahal.aux";
char *swpfilename="megahal.swp";
char *endfilename="megahal.end";
char *learnfilename=NULL;
char *logfilename="megahal.log";
char *textfilename="megahal.txt";
a216 1
int timeout=2;
a217 2
int debug=0;
int method=1;
d223 2
a224 3
int judge=0;
static FILE *errorfp=stderr;
static FILE *statusfp=stdout;
d231 1
a231 1
 *		Function:	main
d246 16
d264 2
a265 2
	initialize_error(logfilename);
	initialize_status(textfilename);
d292 1
a292 2
	load_model(brainfilename, model);
	train(model, learnfilename);
d297 3
a299 4
	ban=initialize_list(banfilename);
	aux=initialize_list(auxfilename);
	fin=initialize_list(endfilename);
	swp=initialize_swap(swpfilename);
a310 2
			case UNKNOWN:
				break;
a313 7
			case HELP:
				help();
				continue;
			case SAVE:
				save_model(brainfilename, model);
				message("Brain has been saved.\n");
				continue;
a316 20
			case USAGE:
				usage();
				continue;
			case CASE:
				uppercase=!uppercase;
				message("Case sensitivity is %s\n", uppercase?"off":"on");
				continue;
			case DEBUG:
				debug=!debug;
				message("Debug is %s\n", debug?"on":"off");
				continue;
			case METHOD:
				set_method();
				continue;
			case LEARN:
				update=!update;
				message("Learn is %s\n", update?"on":"off");
				continue;
			case JUDGE:
				break;
d338 1
a338 1
static COMMAND_WORDS execute_command(DICTIONARY *words)
d342 1
a342 1
	static STRING word={ 2, "@@@@" };
d345 3
d350 7
d358 3
d362 3
d368 3
d383 6
a388 1
static void help(void)
a389 13
	message("Available commands:\n");
	message("- QUIT the program\n");
	message("- SAVE the brain to a file\n");
	message("- STATUS to check memory consumption\n");
	message("- CASE to toggle case sensitivity\n");
	message("- DEBUG to toggle debug messages\n");
	message("- LEARN to toggle learning mode\n");
}

/*---------------------------------------------------------------------------*/

static void setup(void)
{
a408 15
static void set_method(void)
{
	message("Available methods:\n");
	message("0. Total surprise\n");
	message("1. Per-keyword-used surprise\n");
	message("2. Per-root-keyword-used surprise\n");
	message("3. Per-keyword surprise\n");
	message("4. Per-word surprise\n");
	fprintf(stdout, "Method? ");
	fscanf(stdin, "%d", &method);
	message("MegaHAL will use method %d\n", method);
}

/*---------------------------------------------------------------------------*/

a428 1
	input=(char *)malloc(sizeof(char));
d430 5
a434 2
		error("read_input", "Unable to allocate the input string");
		return(input);
d557 1
a557 1
 *		Function:	error
d578 1
a578 1
 *		Function:	initialize_status
d597 1
a597 1
 *		Function:	status
d616 1
a616 1
 *		Function:	print_header
d620 1
a620 1
static bool print_header(FILE *file)
d653 1
a653 1
 *		Function:	rule
d657 1
a657 1
static bool rule(FILE *file, char style)
a754 49
 *		Function:	Usage
 *
 *		Purpose:		Display the memory usage of the program.
 */
void usage(void)
{
	struct rusage *rusage;

	rusage=(struct rusage *)malloc(sizeof(struct rusage));
	if(rusage==NULL) {
		error("Usage", "Unable to allocate structure.");
		return;
	}

	getrusage(RUSAGE_SELF, rusage);

	message("MegaHAL is using %s of memory.\n",
	show_size(1024*8*(rusage->ru_maxrss)));
	free(rusage);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Show_Size
 *
 *		Purpose:		Display a number nicely.
 */
static char *show_size(int bits)
{
	static char string[1024];

	if(bits/(1024*1024*8)>0)
		sprintf(string,"%.2f megabytes",(float)(bits)/(float)(1024*1024*8));
	else if(bits/(1024*8)>0)
		sprintf(string, "%.2f kilobytes",(float)(bits)/(float)(1024*8));
	else if(bits/8>0)
		sprintf(string, "%.2f bytes",(float)(bits)/(float)(8));
	else if(bits>0)
		sprintf(string, "%d bits",bits);
	else
		sprintf(string, "0 bytes");

	return(string);
}

/*---------------------------------------------------------------------------*/

/*
d823 1
a823 1
unsigned int add_word(DICTIONARY *dictionary, STRING word)
d844 1
a844 1
		dictionary->index=(unsigned short *)malloc(sizeof(unsigned short)*
d847 2
a848 2
		dictionary->index=(unsigned short *)realloc((unsigned short *)
		(dictionary->index),sizeof(unsigned short)*(dictionary->size));
d903 1
a903 1
 *		Function:	Search_dictionary
d909 1
a909 1
static int search_dictionary(DICTIONARY *dictionary, STRING word, bool *find)
d975 1
a975 1
 *		Function:	find_word
d981 1
a981 1
unsigned short find_word(DICTIONARY *dictionary, STRING word)
d995 1
a995 1
 *		Function:	wordcmp
d1021 1
a1021 1
 *		Function:	free_dictionary
d1043 1
a1043 1
 *		Function:	Symbol_to_string
d1045 1
a1045 1
 *		Purpose:		Return a character array corresponding to the symbol.
d1047 1
a1047 1
char *symbol_to_string(DICTIONARY *dictionary, int symbol, bool friendly)
a1048 78
	register int i;
	static char *string=NULL;

	if(string==NULL) {
		string=(char *)malloc(sizeof(char)*256);
		if(string==NULL) {
			error("symbol_to_word", "Unable to allocate string.");
			return("[ERROR]");
		}
	}

	strcpy(string, "");	
	for(i=0; i<dictionary->entry[symbol].length; ++i) {
		strcat(string, convert_character(dictionary->entry[symbol].word[i], friendly));
		if(strlen(string)>=200) {
			strcat(string, "... (truncated)");
			break;
		}
	}

	return(string);
}

/*---------------------------------------------------------------------------*/

/*
 *		Function:	Convert_character
 *
 *		Purpose:		Return a representation of the character.
 */
static char *convert_character(char character, bool friendly)
{
	static char *string=NULL;

	if(string==NULL) {
		string=(char *)malloc(sizeof(char)*16);
		if(string==NULL) {
			error("convert_character", "Unable to allocate string.");
			return("[ERROR]");
		}
	}

	if(friendly==FALSE) {
		sprintf(string, "%c", character);
		return(string);
	}

	switch((int)(character)) {
		case 0:
			strcpy(string, "_NULL_");
			break;
		case 9:
			strcpy(string, "_TAB_");
			break;
		case 10:
			strcpy(string, "_NEWLINE_");
			break;
		case 13:
			strcpy(string, "_RETURN_");
			break;
		case 32:
			strcpy(string, "_SPACE_");
			break;
		default:
			if(((int)(character)<=32)||((int)(character)>=127))
				sprintf(string, "_BYTE(%03d)_", (int)(character));
			else
				sprintf(string, "%c", character);
			break;
	}

	return(string);
}

/*---------------------------------------------------------------------------*/

static void initialize_dictionary(DICTIONARY *dictionary)
{
d1058 5
d1084 5
d1100 5
d1117 5
a1121 11
void show_dictionary(DICTIONARY *dictionary)
{
	register int i;

	message("Dictionary has %d entries:\n", dictionary->size);
	for(i=0; i<dictionary->size; ++i)
		message("%d: %d\n", dictionary->index[i]);
}

/*---------------------------------------------------------------------------*/

d1126 1
a1126 1
	fwrite(&(dictionary->size), sizeof(unsigned long), 1, file);
d1132 5
d1142 1
a1142 1
	fread(&size, sizeof(unsigned long), 1, file);
d1148 6
a1153 1
static void save_word(FILE *file, STRING word)
d1157 1
a1157 1
	fwrite(&(word.length), sizeof(unsigned char), 1, file);
d1164 6
a1169 1
static void load_word(FILE *file, DICTIONARY *dictionary)
d1174 1
a1174 1
	fread(&(word.length), sizeof(unsigned char), 1, file);
d1188 1
a1188 1
 *		Function:	new_node
d1193 1
a1193 1
static TREE *new_node(void)
d1226 1
a1226 1
 *		Function:	new_model
d1262 1
a1262 1
 *		Function:	free_model
d1282 1
a1282 1
 *		Function:	free_tree
d1286 1
a1286 1
static bool free_tree(TREE *tree)
d1319 1
a1319 1
 *		Function:	update_model
d1323 1
a1323 1
static void update_model(MODEL *model, int symbol, int pos)
d1345 1
a1345 1
 *		Function:	Update_context
d1349 1
a1349 1
static void update_context(MODEL *model, int symbol)
d1361 1
a1361 1
 *		Function:	add_symbol
d1367 1
a1367 1
static TREE *add_symbol(TREE *tree, unsigned short symbol)
d1390 1
a1390 1
 *		Function:	find_symbol
d1395 1
a1395 1
static TREE *find_symbol(TREE *node, int symbol)
d1417 1
a1417 1
 *		Function:	find_symbol_add
d1424 1
a1424 1
static TREE *find_symbol_add(TREE *node, int symbol)
d1453 1
a1453 1
 *		Function:	add_node
d1458 1
a1458 1
static void add_node(TREE *tree, TREE *node, int position)
d1500 1
a1500 1
 *		Function:	search_node
d1508 1
a1508 1
static int search_node(TREE *node, int symbol, bool *found_symbol)
d1566 1
a1566 1
 *		Function:	Initialize_context
d1570 1
a1570 1
static void initialize_context(MODEL *model)
d1579 7
a1585 1
static char *update_output(char *output, char *word, bool prepend)
d1624 1
a1624 1
	unsigned short symbol;
a1668 4
	/*
	show_tree(model, NULL, model->forward, "");
	show_tree(model, NULL, model->backward, "");
	*/
d1674 5
a1737 4
	/*
	show_tree(model, NULL, model->forward, "");
	*/

a1745 37
static void show_tree(MODEL *model, TREE *parent, TREE *tree, char *branches)
{
   register int i;
   char thing[80];

   if(parent!=NULL) {
      message("+---");
      if(tree->branch>0) message("+-");
      else message("--");
      message("[%s](%f)", symbol_to_string(model->dictionary, (tree->symbol), TRUE),
         (float)(tree->count)/(float)(parent->usage));
   } else {
      message("+");
   }
   if(strlen(branches)>51) {
      message("{...}\n");
      goto fail;
   }
   message("\n");

   for(i=0; i<tree->branch; ++i) {
      sprintf(thing, "%s|   ", branches);
      message("%s\n", thing);
      if(i==(tree->branch-1)) sprintf(thing, "%s    ", branches);
      message("%s", branches);
      show_tree(model, tree, tree->tree[i], thing);
   }

succeed:
   return;

fail:
   return;
}

/*---------------------------------------------------------------------------*/

d1747 1
a1747 1
 *		Function:	save_model
d1764 1
a1764 1
	fwrite(&(model->order), sizeof(unsigned char), 1, file);
d1774 6
a1779 1
static void save_tree(FILE *file, TREE *node)
d1783 4
a1786 4
	fwrite(&(node->symbol), sizeof(unsigned short), 1, file);
	fwrite(&(node->usage), sizeof(unsigned long), 1, file);
	fwrite(&(node->count), sizeof(unsigned short), 1, file);
	fwrite(&(node->branch), sizeof(unsigned short), 1, file);
d1793 6
a1798 1
static void load_tree(FILE *file, TREE *node)
d1802 4
a1805 4
	fread(&(node->symbol), sizeof(unsigned short), 1, file);
	fread(&(node->usage), sizeof(unsigned long), 1, file);
	fread(&(node->count), sizeof(unsigned short), 1, file);
	fread(&(node->branch), sizeof(unsigned short), 1, file);
d1824 1
a1824 1
 *		Function:	load_model
d1826 1
a1826 1
 *		Purpose:		Load a model into memory
d1828 1
a1828 1
void load_model(char *filename, MODEL *model)
d1833 1
a1833 1
	if(filename==NULL) return;
d1838 1
a1838 1
		return;
d1847 1
a1847 1
	fread(&(model->order), sizeof(unsigned char), 1, file);
d1852 1
d1855 1
d1861 1
a1861 1
 *    Function:   make_words
d1863 1
a1863 1
 *    Purpose:    Break a string into an array of words
d1945 1
a1945 1
 *    Function:   generate_reply
d2008 1
a2008 1
static DICTIONARY *make_keywords(MODEL *model, DICTIONARY *words)
d2011 1
a2011 1
	unsigned short *tmp;
d2037 1
a2037 1
	if(keys->size>2) for(i=0; i<words->size; ++i) {
d2053 6
a2058 1
static void add_key(MODEL *model, DICTIONARY *keys, STRING word)
d2075 6
a2080 1
static void add_aux(MODEL *model, DICTIONARY *keys, STRING word)
d2101 1
a2101 1
static DICTIONARY *reply(MODEL *model, DICTIONARY *keys)
d2103 1
a2103 1
	static DICTIONARY *replies=NULL;
d2216 1
a2216 1
static float evaluate_reply(MODEL *model, DICTIONARY *keys, DICTIONARY *words)
d2220 1
a2220 12
	switch(method) {
		case 1:
			return((counter>0)?entropy/(float)counter:0.0);
		case 2:
			return((counter>0)?entropy/(float)sqrt((float)counter):0.0);
		case 3:
			return((keys->size>2)?entropy/(float)(keys->size-2):0.0);
		case 4:
			return((words->size>0)?entropy/(float)(words->size):0.0);
		default:
			return(entropy);
	}
d2230 1
a2230 1
static char *make_output(DICTIONARY *words)
d2232 1
a2232 1
	static char *output=NULL;
d2272 1
a2272 1
int babble(MODEL *model, DICTIONARY *words)
d2300 1
a2300 1
		if(find_word(words, model->dictionary->entry[symbol])!=0) {
d2321 6
a2326 1
static SWAP *new_swap(void)
d2344 6
a2349 1
static void add_swap(SWAP *list, char *s, char *d)
d2373 5
d2410 5
d2451 3
@
